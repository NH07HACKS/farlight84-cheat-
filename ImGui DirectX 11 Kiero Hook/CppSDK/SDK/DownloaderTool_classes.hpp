#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: DownloaderTool

#include "Basic.hpp"

#include "DownloaderTool_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Engine_classes.hpp"


namespace SDK
{

// Class DownloaderTool.DownloaderHttpTask
// 0x02B0 (0x02D8 - 0x0028)
class UDownloaderHttpTask final : public UObject
{
public:
	TMulticastInlineDelegate<void(const int32 BytesSent, const int32 BytesReceived)> OnTaskProgress; // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FDownloaderResponse& Response)> OnTaskSuccess;        // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const EDTFailedType& FailedType, const int32 Errorcode)> OnTaskFailed; // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FDownloaderFailedInfo& FailedInfo)> OnTaskFailedWithInfo; // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FDownloaderCDNFailedInfo& CDNFailedInfo)> OnTaskCDNFailed; // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UDownloaderManager>      Manager;                                           // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_80[0x1F8];                                     // 0x0080(0x01F8)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDownloaderResponse                    DownloadResponse;                                  // 0x0278(0x0060)(Protected, NativeAccessSpecifierProtected)

public:
	void CreateAndProcessHttpRequest();
	void OnWriteFileComplete(bool bWriteResult);
	void SetWriteFilePath(const class FString& InWriteFilePath);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DownloaderHttpTask">();
	}
	static class UDownloaderHttpTask* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDownloaderHttpTask>();
	}
};
static_assert(alignof(UDownloaderHttpTask) == 0x000008, "Wrong alignment on UDownloaderHttpTask");
static_assert(sizeof(UDownloaderHttpTask) == 0x0002D8, "Wrong size on UDownloaderHttpTask");
static_assert(offsetof(UDownloaderHttpTask, OnTaskProgress) == 0x000028, "Member 'UDownloaderHttpTask::OnTaskProgress' has a wrong offset!");
static_assert(offsetof(UDownloaderHttpTask, OnTaskSuccess) == 0x000038, "Member 'UDownloaderHttpTask::OnTaskSuccess' has a wrong offset!");
static_assert(offsetof(UDownloaderHttpTask, OnTaskFailed) == 0x000048, "Member 'UDownloaderHttpTask::OnTaskFailed' has a wrong offset!");
static_assert(offsetof(UDownloaderHttpTask, OnTaskFailedWithInfo) == 0x000058, "Member 'UDownloaderHttpTask::OnTaskFailedWithInfo' has a wrong offset!");
static_assert(offsetof(UDownloaderHttpTask, OnTaskCDNFailed) == 0x000068, "Member 'UDownloaderHttpTask::OnTaskCDNFailed' has a wrong offset!");
static_assert(offsetof(UDownloaderHttpTask, Manager) == 0x000078, "Member 'UDownloaderHttpTask::Manager' has a wrong offset!");
static_assert(offsetof(UDownloaderHttpTask, DownloadResponse) == 0x000278, "Member 'UDownloaderHttpTask::DownloadResponse' has a wrong offset!");

// Class DownloaderTool.DownloaderMainTask
// 0x0188 (0x01B0 - 0x0028)
class UDownloaderMainTask final : public UObject
{
public:
	TMulticastInlineDelegate<void(const struct FDownloaderProgressInfo& ProgressInfo)> OnMainTaskProgress; // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const TArray<struct FDownloaderResponse>& Responses)> OnMainTaskSuccess; // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FDownloaderFailedInfo& FailedInfo)> OnMainTaskFailed; // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FDownloaderCDNFailedInfo& CDNFailedInfo)> OnTaskCDNFailed; // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UDownloaderManager>      Manager;                                           // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FDownloaderResponse>            AllUrlTasksResponses;                              // 0x0070(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UDownloaderSubTask*>             PausingSubTasks;                                   // 0x0080(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FName, class UDownloaderUrlTask*>  AllUrlTasksMap;                                    // 0x0090(0x0050)(Protected, NativeAccessSpecifierProtected)
	TMap<class FString, struct FDownloaderProgressInfo> AllUrlTasksProgressInfoMap;                  // 0x00E0(0x0050)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_130[0x80];                                     // 0x0130(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnUrlTaskCDNFailed(const struct FDownloaderCDNFailedInfo& InCDNFailedInfo);
	void OnUrlTaskFailed(const struct FDownloaderFailedInfo& InFailedInfo);
	void OnUrlTaskProgress(const struct FDownloaderProgressInfo& InProgressInfo);
	void OnUrlTaskSuccess(const struct FDownloaderResponse& InResponse);
	void SetTaskReadyLaunch();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DownloaderMainTask">();
	}
	static class UDownloaderMainTask* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDownloaderMainTask>();
	}
};
static_assert(alignof(UDownloaderMainTask) == 0x000008, "Wrong alignment on UDownloaderMainTask");
static_assert(sizeof(UDownloaderMainTask) == 0x0001B0, "Wrong size on UDownloaderMainTask");
static_assert(offsetof(UDownloaderMainTask, OnMainTaskProgress) == 0x000028, "Member 'UDownloaderMainTask::OnMainTaskProgress' has a wrong offset!");
static_assert(offsetof(UDownloaderMainTask, OnMainTaskSuccess) == 0x000038, "Member 'UDownloaderMainTask::OnMainTaskSuccess' has a wrong offset!");
static_assert(offsetof(UDownloaderMainTask, OnMainTaskFailed) == 0x000048, "Member 'UDownloaderMainTask::OnMainTaskFailed' has a wrong offset!");
static_assert(offsetof(UDownloaderMainTask, OnTaskCDNFailed) == 0x000058, "Member 'UDownloaderMainTask::OnTaskCDNFailed' has a wrong offset!");
static_assert(offsetof(UDownloaderMainTask, Manager) == 0x000068, "Member 'UDownloaderMainTask::Manager' has a wrong offset!");
static_assert(offsetof(UDownloaderMainTask, AllUrlTasksResponses) == 0x000070, "Member 'UDownloaderMainTask::AllUrlTasksResponses' has a wrong offset!");
static_assert(offsetof(UDownloaderMainTask, PausingSubTasks) == 0x000080, "Member 'UDownloaderMainTask::PausingSubTasks' has a wrong offset!");
static_assert(offsetof(UDownloaderMainTask, AllUrlTasksMap) == 0x000090, "Member 'UDownloaderMainTask::AllUrlTasksMap' has a wrong offset!");
static_assert(offsetof(UDownloaderMainTask, AllUrlTasksProgressInfoMap) == 0x0000E0, "Member 'UDownloaderMainTask::AllUrlTasksProgressInfoMap' has a wrong offset!");

// Class DownloaderTool.LuaAsyncLoadTextureBridge
// 0x0010 (0x0038 - 0x0028)
class ULuaAsyncLoadTextureBridge final : public UObject
{
public:
	TMulticastInlineDelegate<void(const class FString& FilePath, class UTexture2DDynamic* Texture)> OnAsyncDownloadOrLoadTextureMultiFinish; // 0x0028(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LuaAsyncLoadTextureBridge">();
	}
	static class ULuaAsyncLoadTextureBridge* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULuaAsyncLoadTextureBridge>();
	}
};
static_assert(alignof(ULuaAsyncLoadTextureBridge) == 0x000008, "Wrong alignment on ULuaAsyncLoadTextureBridge");
static_assert(sizeof(ULuaAsyncLoadTextureBridge) == 0x000038, "Wrong size on ULuaAsyncLoadTextureBridge");
static_assert(offsetof(ULuaAsyncLoadTextureBridge, OnAsyncDownloadOrLoadTextureMultiFinish) == 0x000028, "Member 'ULuaAsyncLoadTextureBridge::OnAsyncDownloadOrLoadTextureMultiFinish' has a wrong offset!");

// Class DownloaderTool.DownloaderManagerLuaImpl
// 0x0008 (0x0030 - 0x0028)
class UDownloaderManagerLuaImpl final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool InitDownloaderMgrLuaInternal();
	void UnInitDownloaderMgrLuaInternal();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DownloaderManagerLuaImpl">();
	}
	static class UDownloaderManagerLuaImpl* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDownloaderManagerLuaImpl>();
	}
};
static_assert(alignof(UDownloaderManagerLuaImpl) == 0x000008, "Wrong alignment on UDownloaderManagerLuaImpl");
static_assert(sizeof(UDownloaderManagerLuaImpl) == 0x000030, "Wrong size on UDownloaderManagerLuaImpl");

// Class DownloaderTool.DownloaderManager
// 0x0240 (0x0270 - 0x0030)
class UDownloaderManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(bool bSuccess)>                OnCopyPakFileComplete;                             // 0x0040(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	class UDownloaderManagerLuaImpl*              LuaImpl;                                           // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsDownloaderEnabled;                              // 0x0058(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSystemSupportFileCache;                           // 0x0059(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsBackgroundDownload;                             // 0x005A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5B[0x1];                                       // 0x005B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CacheExpiredSeconds;                               // 0x005C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CacheClearMaxSpacePercent;                         // 0x0060(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TextureMaxCacheNum;                                // 0x0064(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TextureCacheExpireTime;                            // 0x0068(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeOutSeconds;                                    // 0x006C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         UrlTaskCallbackTimeOutSeconds;                     // 0x0070(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         UrlTaskCallbackTimeOutGrowFactor;                  // 0x0074(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SubTaskChunkSize;                                  // 0x0078(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurDownloadingSubTaskNum;                          // 0x007C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxDownloadingSubTaskNum;                          // 0x0080(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         BackgroundDownloadMaxRetryTimes;                   // 0x0084(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 DefaultLaunchCacheDir;                             // 0x0088(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 DefaultPictureCacheDir;                            // 0x0098(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 DefaultLogsCacheDir;                               // 0x00A8(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FName, class UDownloaderMainTask*> MainTasksMap;                                      // 0x00B8(0x0050)(Protected, NativeAccessSpecifierProtected)
	TMap<class FString, class UDownloaderHttpTask*> LightWeightHttpTasksMap;                         // 0x0108(0x0050)(Protected, NativeAccessSpecifierProtected)
	TMap<class FString, class FString>            UrlEncodedStrMap;                                  // 0x0158(0x0050)(Protected, NativeAccessSpecifierProtected)
	TArray<class UDownloaderSubTask*>             SubTasksQueue;                                     // 0x01A8(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TWeakObjectPtr<class UDownloaderSubTask>> CurRunningSubTasks;                             // 0x01B8(0x0010)(ZeroConstructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInitLuaComplete;                                  // 0x01C8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C9[0x2F];                                     // 0x01C9(0x002F)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, struct FCacheEntry>       TextureCache;                                      // 0x01F8(0x0050)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_248[0x28];                                     // 0x0248(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UDownloaderManager* Get(const class UObject* WorldContextObject);
	static class FName GetMainTaskName(const TArray<struct FDownloaderTaskInfo>& InAllTaskInfos);

	void AsyncLoadOrDownloadTexture(const struct FDownloaderTaskInfo& InTaskInfo, const TDelegate<void(const class FString& FilePath, class UTexture2DDynamic* Texture)>& Callback);
	void Clear();
	void ClearCache();
	void ClearCompletedLightWeightHttpTask();
	void ClearCompletedMainTask();
	class UDownloaderMainTask* CreateBigFilesDownloadTask(const TArray<struct FDownloaderTaskInfo>& InAllTaskInfos);
	class UDownloaderHttpTask* CreateJsonReqTask(const class FString& InNecessaryURL, const struct FDownloaderReqJson& InReqJson);
	class UDownloaderHttpTask* CreateLightWeightTask(const struct FDownloaderTaskInfo& InTaskInfo);
	class ULuaAsyncLoadTextureBridge* CreateLuaAsyncLoadOrDownloadTextureTask(const struct FDownloaderTaskInfo& InTaskInfo);
	bool DeleteAllDefaultCacheDir();
	void ForceClearAllTextureCaches();
	class FString GetDefaultPictureCacheFilePath(const struct FDownloaderTaskInfo& InTaskInfo);
	class UDownloaderMainTask* GetMainTaskByName(const class FName& InMainTaskName);
	TMap<class FName, class UDownloaderMainTask*> GetMainTasksMap();
	EDownloaderStatus GetMainTaskStatus(const class FName& InMainTaskName);
	class ULuaAsyncLoadTextureBridge* GetTextureBridge(const struct FDownloaderTaskInfo& InTaskInfo);
	class FString GetUrlEncodedStr(const struct FDownloaderTaskInfo& InTaskInfo);
	int32 GetUrlsCachedSize(const TArray<struct FDownloaderTaskInfo>& InAllTaskInfos);
	class FString GetUrlTaskCacheDirPath(const struct FDownloaderTaskInfo& InTaskInfo);
	class FString GetUrlTaskRecordFilePath(const struct FDownloaderTaskInfo& InTaskInfo);
	void HandleTextureConversionComplete(const class FString& FilePath, class UTexture2DDynamic* Texture);
	void Init();
	bool IsMainTaskExist(const class FName& InMainTaskName);
	void OnDownloadTextureFailed(const struct FDownloaderFailedInfo& InFailedInfo);
	void OnDownloadTextureSuccess(const struct FDownloaderResponse& InResponses);
	void PauseMainTask(const class FName& InMainTaskName);
	void PushBatchSubTasksToQueue(const TArray<class UDownloaderSubTask*>& InSubTasks, const bool bInCutQueue);
	void ReadyMainTaskFinish(const class FName& InMainTaskName);
	void ResumeMainTask(const class FName& InMainTaskName);
	void SetBackgroundDownloadMaxRetryTimes(const int32 InMaxRetryTimes);
	void SetByExpectedMaxDownloadingSubTaskNum();
	void SetCacheClearMaxSpacePercent(const int32 InCacheClearMaxSpacePercent);
	void SetCacheExpiredSeconds(const int32 InCacheExpiredSeconds);
	void SetIsBackgroundDownload(const bool bInBackgroundDownload);
	void SetManagerEnable(const bool bInEnable);
	void SetMaxDownloadingSubTaskNum(const int32 InMaxDownloadingSubTaskNum);
	void SetSubTaskChunkSize(const int32 InSubTaskChunkSize);
	void SetTextureCacheExpireTime(const float InTextureCacheExpireTime);
	void SetTextureMaxCacheNum(const int32 InTextureMaxCacheNum);
	void SetTimeOutSeconds(const float InTimeOutSeconds);
	void SetUrlTaskCallbackTimeOutGrowFactor(const float InGrowFactor);
	void SetUrlTaskCallbackTimeOutSeconds(const float InTimeOutSeconds);
	void StopAllMainTasks();
	void StopMainTask(const class FName& InMainTaskName);
	void TryLaunchSubTasksQueue();

	bool CheckTaskInfosValid(const TArray<struct FDownloaderTaskInfo>& InAllTaskInfos) const;
	bool DeleteDefaultLaunchCacheDir() const;
	bool DeleteDefaultLogsCacheDir() const;
	bool DeleteDefaultPictureCacheDir() const;
	int32 GetBackgroundDownloadMaxRetryTimes() const;
	int32 GetCacheClearMaxSpacePercent() const;
	int32 GetCacheExpiredSeconds() const;
	class FString GetDefaultLaunchCacheDir() const;
	class FString GetDefaultLogsCacheDir() const;
	class FString GetDefaultPictureCacheDir() const;
	bool GetIsBackgroundDownload() const;
	class UDownloaderHttpTask* GetLightWeightHttpTaskByURL(const class FString& InNecessaryURL) const;
	int32 GetMaxDownloadingSubTaskNum() const;
	int32 GetSubTaskChunkSize() const;
	float GetTextureCacheExpireTime() const;
	int32 GetTextureMaxCacheNum() const;
	float GetTimeOutSeconds() const;
	float GetUrlTaskCallbackTimeOutGrowFactor() const;
	float GetUrlTaskCallbackTimeOutSeconds() const;
	bool IsManagerEnable() const;
	bool IsSystemSupportFileCache() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DownloaderManager">();
	}
	static class UDownloaderManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDownloaderManager>();
	}
};
static_assert(alignof(UDownloaderManager) == 0x000008, "Wrong alignment on UDownloaderManager");
static_assert(sizeof(UDownloaderManager) == 0x000270, "Wrong size on UDownloaderManager");
static_assert(offsetof(UDownloaderManager, OnCopyPakFileComplete) == 0x000040, "Member 'UDownloaderManager::OnCopyPakFileComplete' has a wrong offset!");
static_assert(offsetof(UDownloaderManager, LuaImpl) == 0x000050, "Member 'UDownloaderManager::LuaImpl' has a wrong offset!");
static_assert(offsetof(UDownloaderManager, bIsDownloaderEnabled) == 0x000058, "Member 'UDownloaderManager::bIsDownloaderEnabled' has a wrong offset!");
static_assert(offsetof(UDownloaderManager, bSystemSupportFileCache) == 0x000059, "Member 'UDownloaderManager::bSystemSupportFileCache' has a wrong offset!");
static_assert(offsetof(UDownloaderManager, bIsBackgroundDownload) == 0x00005A, "Member 'UDownloaderManager::bIsBackgroundDownload' has a wrong offset!");
static_assert(offsetof(UDownloaderManager, CacheExpiredSeconds) == 0x00005C, "Member 'UDownloaderManager::CacheExpiredSeconds' has a wrong offset!");
static_assert(offsetof(UDownloaderManager, CacheClearMaxSpacePercent) == 0x000060, "Member 'UDownloaderManager::CacheClearMaxSpacePercent' has a wrong offset!");
static_assert(offsetof(UDownloaderManager, TextureMaxCacheNum) == 0x000064, "Member 'UDownloaderManager::TextureMaxCacheNum' has a wrong offset!");
static_assert(offsetof(UDownloaderManager, TextureCacheExpireTime) == 0x000068, "Member 'UDownloaderManager::TextureCacheExpireTime' has a wrong offset!");
static_assert(offsetof(UDownloaderManager, TimeOutSeconds) == 0x00006C, "Member 'UDownloaderManager::TimeOutSeconds' has a wrong offset!");
static_assert(offsetof(UDownloaderManager, UrlTaskCallbackTimeOutSeconds) == 0x000070, "Member 'UDownloaderManager::UrlTaskCallbackTimeOutSeconds' has a wrong offset!");
static_assert(offsetof(UDownloaderManager, UrlTaskCallbackTimeOutGrowFactor) == 0x000074, "Member 'UDownloaderManager::UrlTaskCallbackTimeOutGrowFactor' has a wrong offset!");
static_assert(offsetof(UDownloaderManager, SubTaskChunkSize) == 0x000078, "Member 'UDownloaderManager::SubTaskChunkSize' has a wrong offset!");
static_assert(offsetof(UDownloaderManager, CurDownloadingSubTaskNum) == 0x00007C, "Member 'UDownloaderManager::CurDownloadingSubTaskNum' has a wrong offset!");
static_assert(offsetof(UDownloaderManager, MaxDownloadingSubTaskNum) == 0x000080, "Member 'UDownloaderManager::MaxDownloadingSubTaskNum' has a wrong offset!");
static_assert(offsetof(UDownloaderManager, BackgroundDownloadMaxRetryTimes) == 0x000084, "Member 'UDownloaderManager::BackgroundDownloadMaxRetryTimes' has a wrong offset!");
static_assert(offsetof(UDownloaderManager, DefaultLaunchCacheDir) == 0x000088, "Member 'UDownloaderManager::DefaultLaunchCacheDir' has a wrong offset!");
static_assert(offsetof(UDownloaderManager, DefaultPictureCacheDir) == 0x000098, "Member 'UDownloaderManager::DefaultPictureCacheDir' has a wrong offset!");
static_assert(offsetof(UDownloaderManager, DefaultLogsCacheDir) == 0x0000A8, "Member 'UDownloaderManager::DefaultLogsCacheDir' has a wrong offset!");
static_assert(offsetof(UDownloaderManager, MainTasksMap) == 0x0000B8, "Member 'UDownloaderManager::MainTasksMap' has a wrong offset!");
static_assert(offsetof(UDownloaderManager, LightWeightHttpTasksMap) == 0x000108, "Member 'UDownloaderManager::LightWeightHttpTasksMap' has a wrong offset!");
static_assert(offsetof(UDownloaderManager, UrlEncodedStrMap) == 0x000158, "Member 'UDownloaderManager::UrlEncodedStrMap' has a wrong offset!");
static_assert(offsetof(UDownloaderManager, SubTasksQueue) == 0x0001A8, "Member 'UDownloaderManager::SubTasksQueue' has a wrong offset!");
static_assert(offsetof(UDownloaderManager, CurRunningSubTasks) == 0x0001B8, "Member 'UDownloaderManager::CurRunningSubTasks' has a wrong offset!");
static_assert(offsetof(UDownloaderManager, bInitLuaComplete) == 0x0001C8, "Member 'UDownloaderManager::bInitLuaComplete' has a wrong offset!");
static_assert(offsetof(UDownloaderManager, TextureCache) == 0x0001F8, "Member 'UDownloaderManager::TextureCache' has a wrong offset!");

// Class DownloaderTool.DownloaderSubTask
// 0x0158 (0x0180 - 0x0028)
class UDownloaderSubTask final : public UObject
{
public:
	TDelegate<void(const int32 BytesSent, const int32 BytesReceived)> OnSubTaskProgress;             // 0x0028(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(const struct FDownloaderResponse& Response)> OnSubTaskSuccess;                    // 0x0038(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(const EDTFailedType& FailedType, const int32 Errorcode)> OnSubTaskFailed;         // 0x0048(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FDownloaderCDNFailedInfo& CDNFailedInfo)> OnTaskCDNFailed; // 0x0058(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UDownloaderManager>      Manager;                                           // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDownloaderHttpTask*                    RealHttpTask;                                      // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_78[0x108];                                     // 0x0078(0x0108)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRealHttpTaskCDNFailed(const struct FDownloaderCDNFailedInfo& InCDNFailedInfo);
	void OnRealHttpTaskFailed(const EDTFailedType& InFailedType, const int32 InErrorCode);
	void OnRealHttpTaskProgress(const int32 InBytesSent, const int32 InBytesReceived);
	void OnRealHttpTaskSuccess(const struct FDownloaderResponse& InResponse);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DownloaderSubTask">();
	}
	static class UDownloaderSubTask* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDownloaderSubTask>();
	}
};
static_assert(alignof(UDownloaderSubTask) == 0x000008, "Wrong alignment on UDownloaderSubTask");
static_assert(sizeof(UDownloaderSubTask) == 0x000180, "Wrong size on UDownloaderSubTask");
static_assert(offsetof(UDownloaderSubTask, OnSubTaskProgress) == 0x000028, "Member 'UDownloaderSubTask::OnSubTaskProgress' has a wrong offset!");
static_assert(offsetof(UDownloaderSubTask, OnSubTaskSuccess) == 0x000038, "Member 'UDownloaderSubTask::OnSubTaskSuccess' has a wrong offset!");
static_assert(offsetof(UDownloaderSubTask, OnSubTaskFailed) == 0x000048, "Member 'UDownloaderSubTask::OnSubTaskFailed' has a wrong offset!");
static_assert(offsetof(UDownloaderSubTask, OnTaskCDNFailed) == 0x000058, "Member 'UDownloaderSubTask::OnTaskCDNFailed' has a wrong offset!");
static_assert(offsetof(UDownloaderSubTask, Manager) == 0x000068, "Member 'UDownloaderSubTask::Manager' has a wrong offset!");
static_assert(offsetof(UDownloaderSubTask, RealHttpTask) == 0x000070, "Member 'UDownloaderSubTask::RealHttpTask' has a wrong offset!");

// Class DownloaderTool.DownloaderUrlTask
// 0x02C0 (0x02E8 - 0x0028)
class UDownloaderUrlTask final : public UObject
{
public:
	TDelegate<void(const struct FDownloaderProgressInfo& ProgressInfo)> OnUrlTaskProgress;           // 0x0028(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(const struct FDownloaderResponse& Response)> OnUrlTaskSuccess;                    // 0x0038(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(const struct FDownloaderFailedInfo& FailedInfo)> OnUrlTaskFailed;                 // 0x0048(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FDownloaderCDNFailedInfo& CDNFailedInfo)> OnTaskCDNFailed; // 0x0058(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UDownloaderManager>      Manager;                                           // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FName, class UDownloaderSubTask*>  AllSubTasksMap;                                    // 0x0070(0x0050)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_C0[0x228];                                     // 0x00C0(0x0228)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CheckUrlTaskSuccess();
	void CreateSubTasksPerFrame();
	void OnHashCheckFileComplete(const bool bHashCheckResult);
	void OnMergeFileComplete(const bool bMergeResult);
	void OnMoveOrCopyFileComplete(const bool bMoveOrCopyResult);
	void OnSubTaskCDNFailed(const struct FDownloaderCDNFailedInfo& InCDNFailedInfo);
	void OnSubTaskFailed(const EDTFailedType& InFailedType, const int32 InErrorCode);
	void OnSubTaskProgress(const int32 InCurBytesSent, const int32 InCurBytesReceived);
	void OnSubTaskSuccess(const struct FDownloaderResponse& InResponse);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DownloaderUrlTask">();
	}
	static class UDownloaderUrlTask* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDownloaderUrlTask>();
	}
};
static_assert(alignof(UDownloaderUrlTask) == 0x000008, "Wrong alignment on UDownloaderUrlTask");
static_assert(sizeof(UDownloaderUrlTask) == 0x0002E8, "Wrong size on UDownloaderUrlTask");
static_assert(offsetof(UDownloaderUrlTask, OnUrlTaskProgress) == 0x000028, "Member 'UDownloaderUrlTask::OnUrlTaskProgress' has a wrong offset!");
static_assert(offsetof(UDownloaderUrlTask, OnUrlTaskSuccess) == 0x000038, "Member 'UDownloaderUrlTask::OnUrlTaskSuccess' has a wrong offset!");
static_assert(offsetof(UDownloaderUrlTask, OnUrlTaskFailed) == 0x000048, "Member 'UDownloaderUrlTask::OnUrlTaskFailed' has a wrong offset!");
static_assert(offsetof(UDownloaderUrlTask, OnTaskCDNFailed) == 0x000058, "Member 'UDownloaderUrlTask::OnTaskCDNFailed' has a wrong offset!");
static_assert(offsetof(UDownloaderUrlTask, Manager) == 0x000068, "Member 'UDownloaderUrlTask::Manager' has a wrong offset!");
static_assert(offsetof(UDownloaderUrlTask, AllSubTasksMap) == 0x000070, "Member 'UDownloaderUrlTask::AllSubTasksMap' has a wrong offset!");

// Class DownloaderTool.DownloaderUtils
// 0x0000 (0x0028 - 0x0028)
class UDownloaderUtils final : public UObject
{
public:
	static void AsyncCopyFileFromPak(const class FString& SourceFilePath, const class FString& TargetFilePath);
	static class FString DecodeFileRawData(const struct FDownloaderResponse& InResponse);
	static class FString EncodeUrl(const class FString& InUnencodeUrl);
	static void ExtractFileNameAndExtensionFromFileFullName(const class FString& InFileFullName, class FString* OutFileName, class FString* OutFileExtension);
	static class FString GetAllTaskNameLogStr(const class FString& InMainTaskName, const class FString& InUrlTaskName, const class FString& InSubTaskName, const class FString& InHttpTaskName);
	static class FString GetBodyFromJsonRequestStr(const class FString& JsonRequestStr);
	static int64 GetCurTimeMilliSecond();
	static class FString GetFailedTypeStr(const EDTFailedType& InFailedType);
	static TMap<class FString, class FString> GetHeadersFromJsonRequestStr(const class FString& JsonRequestStr);
	static class FString GetHttpMethodTypeStr(const EDownloaderHttpMethod& InHttpMethod);
	static TMap<class FString, class FString> GetQueriesFromJsonRequestStr(const class FString& JsonRequestStr);
	static class FString GetTaskInfoLogStr(const struct FDownloaderTaskInfo& InTaskInfo);
	static class FString GetVerbFromJsonRequestStr(const class FString& JsonRequestStr);
	static bool HashCheckFile(const class FString& InFilePath, const class FString& InHashStr);
	static class FString HashStringWithSHA1(const class FString& inString);
	static void SafeWriteToFile(const class FString& InFilePath, const class FString& InContent, bool bInAppend, bool bInReplaceOld);
	static class FString StringFileRawData(const struct FDownloaderResponse& InResponse);
	static bool TryDeleteOldFileAndCreateDir(const class FString& InFileFullPath);
	static bool TryGetJsonStrFromDownloaderReqJson(const struct FDownloaderReqJson& InReqJson, class FString* OutReqStr);
	static bool TryGetResponseFromCache(const struct FDownloaderTaskInfo& InTaskInfo, const class FString& InCachePath, struct FDownloaderResponse* OutResponse);
	static bool TryGetUrlTaskRecordFromFile(const class FString& InUrlTaskRecordFilePath, struct FUrlTaskRecordInfo* OutUrlTaskRecordInfo);
	static bool TrySaveResponseToCache(const struct FDownloaderResponse& InResponse, const class FString& InCachePath);
	static bool TryUpdateUrlTaskRecordFile(const class FString& InUrlTaskRecordFilePath, const struct FUrlTaskRecordInfo& InUrlTaskRecordInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DownloaderUtils">();
	}
	static class UDownloaderUtils* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDownloaderUtils>();
	}
};
static_assert(alignof(UDownloaderUtils) == 0x000008, "Wrong alignment on UDownloaderUtils");
static_assert(sizeof(UDownloaderUtils) == 0x000028, "Wrong size on UDownloaderUtils");

}

