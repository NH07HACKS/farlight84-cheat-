#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: HotPatcherRuntime

#include "Basic.hpp"

#include "Engine_classes.hpp"
#include "HotPatcherRuntime_structs.hpp"
#include "CoreUObject_classes.hpp"


namespace SDK
{

// Class HotPatcherRuntime.FlibAssetManageHelper
// 0x0000 (0x0028 - 0x0028)
class UFlibAssetManageHelper final : public UBlueprintFunctionLibrary
{
public:
	static struct FAssetDependenciesInfo CombineAssetDependencies(const struct FAssetDependenciesInfo& A, const struct FAssetDependenciesInfo& B);
	static bool CombineAssetsDetailAsFAssetDepenInfo(const TArray<struct FAssetDetail>& InAssetsDetailList, struct FAssetDependenciesInfo* OutAssetInfo);
	static bool ConvLongPackageNameToCookedPath(const class FString& InProjectAbsDir, const class FString& InPlatformName, const class FString& InLongPackageName, TArray<class FString>* OutCookedAssetPath, TArray<class FString>* OutCookedAssetRelativePath);
	static bool ConvRelativeDirToAbsDir(const class FString& InRelativePath, class FString* OutAbsPath);
	static bool ExportCookPakCommandToFile(const TArray<class FString>& InCommand, const class FString& InFile);
	static bool FilenameToPackagePath(const class FString& InAbsPath, class FString* OutPackagePath);
	static void FilterNoRefAssets(const TArray<struct FAssetDetail>& InAssetsDetail, TArray<struct FAssetDetail>* OutHasRefAssetsDetail, TArray<struct FAssetDetail>* OutDontHasRefAssetsDetail);
	static void FilterNoRefAssetsWithIgnoreFilter(const TArray<struct FAssetDetail>& InAssetsDetail, const TArray<class FString>& InIgnoreFilters, TArray<struct FAssetDetail>* OutHasRefAssetsDetail, TArray<struct FAssetDetail>* OutDontHasRefAssetsDetail);
	static bool FindFilesRecursive(const class FString& InStartDir, TArray<class FString>* OutFileList, bool InRecursive);
	static void GetAllEnabledModuleName(TMap<class FString, class FString>* OutModules);
	static bool GetAssetPackageGUID(const class FString& InPackagePath, class FName* OutGUID);
	static bool GetAssetReferenceEx(const struct FAssetDetail& InAsset, const TArray<EAssetRegistryDependencyTypeEx>& SearchAssetDepTypes, TArray<struct FAssetDetail>* OutRefAsset);
	static bool GetEnableModuleAbsDir(const class FString& InModuleName, class FString* OutPath);
	static bool GetModuleNameByRelativePath(const class FString& InRelativePath, class FString* OutModuleName);
	static bool GetPluginModuleAbsDir(const class FString& InPluginModuleName, class FString* OutPath);
	static bool GetRedirectorList(const TArray<class FString>& InFilterPackagePaths, TArray<struct FAssetDetail>* OutRedirector);
	static bool GetSpecifyAssetDetail(const class FString& InLongPackageName, struct FAssetDetail* OutAssetDetail);
	static bool LoadFileToString(const class FString& InFile, class FString* OutString);
	static class FString LongPackageNameToPackagePath(const class FString& InLongPackageName);
	static bool ModuleIsEnabled(const class FString& InModuleName);
	static class FString PackagePathToFilename(const class FString& InPackagePath);
	static bool SaveStringToFile(const class FString& InFile, const class FString& inString);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlibAssetManageHelper">();
	}
	static class UFlibAssetManageHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlibAssetManageHelper>();
	}
};
static_assert(alignof(UFlibAssetManageHelper) == 0x000008, "Wrong alignment on UFlibAssetManageHelper");
static_assert(sizeof(UFlibAssetManageHelper) == 0x000028, "Wrong size on UFlibAssetManageHelper");

// Class HotPatcherRuntime.FlibPakHelper
// 0x0000 (0x0028 - 0x0028)
class UFlibPakHelper final : public UBlueprintFunctionLibrary
{
public:
	static void CloseShaderbytecode(const class FString& LibraryName);
	static bool CreateFileByBytes(const class FString& InFile, const TArray<uint8>& InBytes, int32 InWriteFlag);
	static void ExecMountPak(const class FString& InPakPath, int32 InPakOrder, const class FString& InMountPoint);
	static TArray<class FString> GetAllMountedPaks();
	static int32 GetPakOrderByPakPath(const class FString& PakFile);
	static bool LoadAssetRegistry(const class FString& LibraryName, const class FString& LibraryDir);
	static bool LoadShaderbytecode(const class FString& LibraryName, const class FString& LibraryDir);
	static bool MountPak(const class FString& PakPath, int32 PakOrder, const class FString& InMountPoint);
	static bool OpenPSO(const class FString& Name_0);
	static void ReloadShaderbytecode();
	static TArray<class FString> ScanAllVersionDescribleFiles();
	static bool ScanExtenFilesInDirectory(const class FString& InRelativePath, const class FString& InExtenPostfix, bool InRecursively, TArray<class FString>* OutFiles);
	static TArray<class FString> ScanExtenPakFiles();
	static bool ScanPlatformDirectory(const class FString& InRelativePath, bool bIncludeFile, bool bIncludeDir, bool bRecursively, TArray<class FString>* OutResault);
	static bool UnMountPak(const class FString& PakPath);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlibPakHelper">();
	}
	static class UFlibPakHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlibPakHelper>();
	}
};
static_assert(alignof(UFlibPakHelper) == 0x000008, "Wrong alignment on UFlibPakHelper");
static_assert(sizeof(UFlibPakHelper) == 0x000028, "Wrong size on UFlibPakHelper");

// Class HotPatcherRuntime.FlibPatchParserHelper
// 0x0000 (0x0028 - 0x0028)
class UFlibPatchParserHelper final : public UBlueprintFunctionLibrary
{
public:
	static void CloseShaderbytecode(const class FString& LibraryName);
	static bool DiffVersionAllPlatformExFiles(const struct FHotPatcherVersion& InBaseVersion, const struct FHotPatcherVersion& InNewVersion, TMap<ETargetPlatform, struct FPatchVersionExternDiff>* OutDiff);
	static bool DiffVersionAssets(const struct FAssetDependenciesInfo& InNewVersion, const struct FAssetDependenciesInfo& InBaseVersion, struct FAssetDependenciesInfo* OutAddAsset, struct FAssetDependenciesInfo* OutModifyAsset, struct FAssetDependenciesInfo* OutDeleteAsset);
	static struct FPlatformExternFiles GetAllExFilesByPlatform(const struct FPlatformExternAssets& InPlatformConf, bool InGeneratedHash);
	static TArray<class FString> GetAvailableMaps(const class FString& GameName, bool IncludeEngineMaps, bool IncludePluginMaps, bool Sorted);
	static bool GetCookedAssetRegistryFiles(const class FString& InProjectAbsDir, const class FString& InProjectName, const class FString& InPlatformName, class FString* OutFiles);
	static TArray<class FString> GetCookedGlobalShaderCacheFiles(const class FString& InProjectDir, const class FString& InPlatformName);
	static bool GetCookedShaderBytecodeFiles(const class FString& InProjectAbsDir, const class FString& InProjectName, const class FString& InPlatformName, bool InGalobalBytecode, bool InProjectBytecode, TArray<class FString>* OutFiles);
	static TArray<class FString> GetEnabledPluginConfigs(const class FString& InPlatformName);
	static TArray<class FString> GetEngineConfigs(const class FString& InPlatformName);
	static TArray<class FString> GetIniConfigs(const class FString& InSearchDir, const class FString& InPlatformName);
	static bool GetPakFileInfo(const class FString& InFile, struct FPakFileInfo* OutFileInfo);
	static class FString GetProjectFilePath();
	static TArray<class FString> GetProjectIniFiles(const class FString& InProjectDir, const class FString& InPlatformName);
	static class FString GetProjectName();
	static class FString HashStringWithSHA1(const class FString& inString);
	static bool LoadShaderbytecode(const class FString& LibraryName, const class FString& LibraryDir);
	static void ReloadShaderbytecode();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlibPatchParserHelper">();
	}
	static class UFlibPatchParserHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlibPatchParserHelper>();
	}
};
static_assert(alignof(UFlibPatchParserHelper) == 0x000008, "Wrong alignment on UFlibPatchParserHelper");
static_assert(sizeof(UFlibPatchParserHelper) == 0x000028, "Wrong size on UFlibPatchParserHelper");

// Class HotPatcherRuntime.FlibShaderPipelineCacheHelper
// 0x0000 (0x0028 - 0x0028)
class UFlibShaderPipelineCacheHelper final : public UBlueprintFunctionLibrary
{
public:
	static bool EnableLogPSO(bool bEnable);
	static bool EnableSaveBoundPSOLog(bool bEnable);
	static bool EnableShaderPipelineCache(bool bEnable);
	static bool IsEnabledLogPSO();
	static bool IsEnabledSaveBoundPSOLog();
	static bool IsEnabledUsePSO();
	static bool LoadShaderPipelineCache(const class FString& Name_0);
	static bool SavePipelineFileCache(EPSOSaveMode Mode);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlibShaderPipelineCacheHelper">();
	}
	static class UFlibShaderPipelineCacheHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlibShaderPipelineCacheHelper>();
	}
};
static_assert(alignof(UFlibShaderPipelineCacheHelper) == 0x000008, "Wrong alignment on UFlibShaderPipelineCacheHelper");
static_assert(sizeof(UFlibShaderPipelineCacheHelper) == 0x000028, "Wrong size on UFlibShaderPipelineCacheHelper");

// Class HotPatcherRuntime.MountListener
// 0x0070 (0x0098 - 0x0028)
class UMountListener final : public UObject
{
public:
	TMulticastInlineDelegate<void(const struct FPakMountInfo& PakInfo)> OnMountPakDelegate;          // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class FString& PakName)> OnUnMountPakDelegate;               // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x50];                                      // 0x0048(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Init();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MountListener">();
	}
	static class UMountListener* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMountListener>();
	}
};
static_assert(alignof(UMountListener) == 0x000008, "Wrong alignment on UMountListener");
static_assert(sizeof(UMountListener) == 0x000098, "Wrong size on UMountListener");
static_assert(offsetof(UMountListener, OnMountPakDelegate) == 0x000028, "Member 'UMountListener::OnMountPakDelegate' has a wrong offset!");
static_assert(offsetof(UMountListener, OnUnMountPakDelegate) == 0x000038, "Member 'UMountListener::OnUnMountPakDelegate' has a wrong offset!");

// Class HotPatcherRuntime.ScopedSlowTaskContext
// 0x0008 (0x0030 - 0x0028)
class UScopedSlowTaskContext final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScopedSlowTaskContext">();
	}
	static class UScopedSlowTaskContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScopedSlowTaskContext>();
	}
};
static_assert(alignof(UScopedSlowTaskContext) == 0x000008, "Wrong alignment on UScopedSlowTaskContext");
static_assert(sizeof(UScopedSlowTaskContext) == 0x000030, "Wrong size on UScopedSlowTaskContext");

}

