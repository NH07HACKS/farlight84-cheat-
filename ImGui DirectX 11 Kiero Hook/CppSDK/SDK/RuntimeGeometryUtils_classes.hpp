#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: RuntimeGeometryUtils

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "RuntimeGeometryUtils_structs.hpp"
#include "ModelingComponents_classes.hpp"
#include "CoreUObject_structs.hpp"


namespace SDK
{

// Class RuntimeGeometryUtils.SolarBaseDynamicMeshComponent
// 0x00A0 (0x08C0 - 0x0820)
#pragma pack(push, 0x1)
class alignas(0x10) USolarBaseDynamicMeshComponent : public USimpleDynamicMeshComponent
{
public:
	class UMaterialInterface*                     Material;                                          // 0x0820(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MeshTag;                                           // 0x0828(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDynamicMeshNormalsMode                       NormalsMode;                                       // 0x0830(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionTraceFlag                           CollisionType;                                     // 0x0831(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseAsyncCooking;                                  // 0x0832(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableComplexCollision;                           // 0x0833(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDeferCollisionUpdates;                            // 0x0834(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_835[0x3];                                      // 0x0835(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UBodySetup*                             MeshBodySetup;                                     // 0x0838(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FKAggregateGeom                        AggGeom;                                           // 0x0840(0x0058)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_898[0x8];                                      // 0x0898(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UBodySetup*>                     AsyncBodySetupQueue;                               // 0x08A0(0x0010)(ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8B0[0x8];                                      // 0x08B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetTriangleCount();
	void UpdateMeshWithTag(class FName* NewTag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SolarBaseDynamicMeshComponent">();
	}
	static class USolarBaseDynamicMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USolarBaseDynamicMeshComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(USolarBaseDynamicMeshComponent) == 0x000010, "Wrong alignment on USolarBaseDynamicMeshComponent");
static_assert(sizeof(USolarBaseDynamicMeshComponent) == 0x0008C0, "Wrong size on USolarBaseDynamicMeshComponent");
static_assert(offsetof(USolarBaseDynamicMeshComponent, Material) == 0x000820, "Member 'USolarBaseDynamicMeshComponent::Material' has a wrong offset!");
static_assert(offsetof(USolarBaseDynamicMeshComponent, MeshTag) == 0x000828, "Member 'USolarBaseDynamicMeshComponent::MeshTag' has a wrong offset!");
static_assert(offsetof(USolarBaseDynamicMeshComponent, NormalsMode) == 0x000830, "Member 'USolarBaseDynamicMeshComponent::NormalsMode' has a wrong offset!");
static_assert(offsetof(USolarBaseDynamicMeshComponent, CollisionType) == 0x000831, "Member 'USolarBaseDynamicMeshComponent::CollisionType' has a wrong offset!");
static_assert(offsetof(USolarBaseDynamicMeshComponent, bUseAsyncCooking) == 0x000832, "Member 'USolarBaseDynamicMeshComponent::bUseAsyncCooking' has a wrong offset!");
static_assert(offsetof(USolarBaseDynamicMeshComponent, bEnableComplexCollision) == 0x000833, "Member 'USolarBaseDynamicMeshComponent::bEnableComplexCollision' has a wrong offset!");
static_assert(offsetof(USolarBaseDynamicMeshComponent, bDeferCollisionUpdates) == 0x000834, "Member 'USolarBaseDynamicMeshComponent::bDeferCollisionUpdates' has a wrong offset!");
static_assert(offsetof(USolarBaseDynamicMeshComponent, MeshBodySetup) == 0x000838, "Member 'USolarBaseDynamicMeshComponent::MeshBodySetup' has a wrong offset!");
static_assert(offsetof(USolarBaseDynamicMeshComponent, AggGeom) == 0x000840, "Member 'USolarBaseDynamicMeshComponent::AggGeom' has a wrong offset!");
static_assert(offsetof(USolarBaseDynamicMeshComponent, AsyncBodySetupQueue) == 0x0008A0, "Member 'USolarBaseDynamicMeshComponent::AsyncBodySetupQueue' has a wrong offset!");

// Class RuntimeGeometryUtils.DynamicMesh3PoolSubsystem
// 0x0050 (0x0080 - 0x0030)
class UDynamicMesh3PoolSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x50];                                      // 0x0030(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicMesh3PoolSubsystem">();
	}
	static class UDynamicMesh3PoolSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicMesh3PoolSubsystem>();
	}
};
static_assert(alignof(UDynamicMesh3PoolSubsystem) == 0x000008, "Wrong alignment on UDynamicMesh3PoolSubsystem");
static_assert(sizeof(UDynamicMesh3PoolSubsystem) == 0x000080, "Wrong size on UDynamicMesh3PoolSubsystem");

// Class RuntimeGeometryUtils.SolarSmokeWallDynamicMeshComponent
// 0x0010 (0x08D0 - 0x08C0)
class USolarSmokeWallDynamicMeshComponent final : public USolarBaseDynamicMeshComponent
{
public:
	float                                         Thickness;                                         // 0x08B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8BC[0x14];                                     // 0x08BC(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SolarSmokeWallDynamicMeshComponent">();
	}
	static class USolarSmokeWallDynamicMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USolarSmokeWallDynamicMeshComponent>();
	}
};
static_assert(alignof(USolarSmokeWallDynamicMeshComponent) == 0x000010, "Wrong alignment on USolarSmokeWallDynamicMeshComponent");
static_assert(sizeof(USolarSmokeWallDynamicMeshComponent) == 0x0008D0, "Wrong size on USolarSmokeWallDynamicMeshComponent");
static_assert(offsetof(USolarSmokeWallDynamicMeshComponent, Thickness) == 0x0008B8, "Member 'USolarSmokeWallDynamicMeshComponent::Thickness' has a wrong offset!");

// Class RuntimeGeometryUtils.DynamicMeshBaseActor
// 0x0370 (0x0648 - 0x02D8)
class ADynamicMeshBaseActor : public AActor
{
public:
	EDynamicMeshActorSourceType                   SourceType;                                        // 0x02D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDynamicMeshActorNormalsMode                  NormalsMode;                                       // 0x02D9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DA[0x6];                                      // 0x02DA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     Material;                                          // 0x02E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRegenerateOnTick;                                 // 0x02E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E9[0x7];                                      // 0x02E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ImportPath;                                        // 0x02F0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReverseOrientation;                               // 0x0300(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCenterPivot;                                      // 0x0301(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_302[0x2];                                      // 0x0302(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ImportScale;                                       // 0x0304(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDynamicMeshActorPrimitiveType                PrimitiveType;                                     // 0x0308(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_309[0x3];                                      // 0x0309(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TessellationLevel;                                 // 0x030C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimumRadius;                                     // 0x0310(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoxDepthRatio;                                     // 0x0314(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VariableRadius;                                    // 0x0318(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PulseSpeed;                                        // 0x031C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_320[0x288];                                    // 0x0320(0x0288)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bEnableSpatialQueries;                             // 0x05A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableInsideQueries;                              // 0x05A9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5AA[0x96];                                     // 0x05AA(0x0096)(Fixing Size After Last Property [ Dumper-7 ])
	EDynamicMeshActorCollisionMode                CollisionMode;                                     // 0x0640(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_641[0x7];                                      // 0x0641(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BooleanWithMesh(class ADynamicMeshBaseActor* OtherMesh, EDynamicMeshActorBooleanOperation Operation);
	bool ContainsPoint(const struct FVector& WorldPoint, float WindingThreshold);
	void CopyFromMesh(class ADynamicMeshBaseActor* OtherMesh, bool bRecomputeNormals);
	float DistanceToPoint(const struct FVector& WorldPoint, struct FVector* NearestMeshWorldPoint, int32* NearestTriangle, struct FVector* TriBaryCoords);
	int32 GetTriangleCount();
	bool ImportMesh(const class FString& Path, bool bFlipOrientation, bool bRecomputeNormals);
	bool IntersectRay(const struct FVector& RayOrigin, const struct FVector& RayDirection, struct FVector* WorldHitPoint, float* HitDistance, int32* NearestTriangle, struct FVector* TriBaryCoords, float MaxDistance);
	void IntersectWithMesh(class ADynamicMeshBaseActor* OtherMesh);
	struct FVector NearestPoint(const struct FVector& WorldPoint);
	void SimplifyMeshToTriCount(int32 TargetTriangleCount);
	void SolidifyMesh(int32 VoxelResolution, float WindingThreshold);
	void SubtractMesh(class ADynamicMeshBaseActor* OtherMesh);
	void UnionWithMesh(class ADynamicMeshBaseActor* OtherMesh);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicMeshBaseActor">();
	}
	static class ADynamicMeshBaseActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADynamicMeshBaseActor>();
	}
};
static_assert(alignof(ADynamicMeshBaseActor) == 0x000008, "Wrong alignment on ADynamicMeshBaseActor");
static_assert(sizeof(ADynamicMeshBaseActor) == 0x000648, "Wrong size on ADynamicMeshBaseActor");
static_assert(offsetof(ADynamicMeshBaseActor, SourceType) == 0x0002D8, "Member 'ADynamicMeshBaseActor::SourceType' has a wrong offset!");
static_assert(offsetof(ADynamicMeshBaseActor, NormalsMode) == 0x0002D9, "Member 'ADynamicMeshBaseActor::NormalsMode' has a wrong offset!");
static_assert(offsetof(ADynamicMeshBaseActor, Material) == 0x0002E0, "Member 'ADynamicMeshBaseActor::Material' has a wrong offset!");
static_assert(offsetof(ADynamicMeshBaseActor, bRegenerateOnTick) == 0x0002E8, "Member 'ADynamicMeshBaseActor::bRegenerateOnTick' has a wrong offset!");
static_assert(offsetof(ADynamicMeshBaseActor, ImportPath) == 0x0002F0, "Member 'ADynamicMeshBaseActor::ImportPath' has a wrong offset!");
static_assert(offsetof(ADynamicMeshBaseActor, bReverseOrientation) == 0x000300, "Member 'ADynamicMeshBaseActor::bReverseOrientation' has a wrong offset!");
static_assert(offsetof(ADynamicMeshBaseActor, bCenterPivot) == 0x000301, "Member 'ADynamicMeshBaseActor::bCenterPivot' has a wrong offset!");
static_assert(offsetof(ADynamicMeshBaseActor, ImportScale) == 0x000304, "Member 'ADynamicMeshBaseActor::ImportScale' has a wrong offset!");
static_assert(offsetof(ADynamicMeshBaseActor, PrimitiveType) == 0x000308, "Member 'ADynamicMeshBaseActor::PrimitiveType' has a wrong offset!");
static_assert(offsetof(ADynamicMeshBaseActor, TessellationLevel) == 0x00030C, "Member 'ADynamicMeshBaseActor::TessellationLevel' has a wrong offset!");
static_assert(offsetof(ADynamicMeshBaseActor, MinimumRadius) == 0x000310, "Member 'ADynamicMeshBaseActor::MinimumRadius' has a wrong offset!");
static_assert(offsetof(ADynamicMeshBaseActor, BoxDepthRatio) == 0x000314, "Member 'ADynamicMeshBaseActor::BoxDepthRatio' has a wrong offset!");
static_assert(offsetof(ADynamicMeshBaseActor, VariableRadius) == 0x000318, "Member 'ADynamicMeshBaseActor::VariableRadius' has a wrong offset!");
static_assert(offsetof(ADynamicMeshBaseActor, PulseSpeed) == 0x00031C, "Member 'ADynamicMeshBaseActor::PulseSpeed' has a wrong offset!");
static_assert(offsetof(ADynamicMeshBaseActor, bEnableSpatialQueries) == 0x0005A8, "Member 'ADynamicMeshBaseActor::bEnableSpatialQueries' has a wrong offset!");
static_assert(offsetof(ADynamicMeshBaseActor, bEnableInsideQueries) == 0x0005A9, "Member 'ADynamicMeshBaseActor::bEnableInsideQueries' has a wrong offset!");
static_assert(offsetof(ADynamicMeshBaseActor, CollisionMode) == 0x000640, "Member 'ADynamicMeshBaseActor::CollisionMode' has a wrong offset!");

// Class RuntimeGeometryUtils.SolarTrapGrenadeDynamicMeshComponent
// 0x0030 (0x08F0 - 0x08C0)
class USolarTrapGrenadeDynamicMeshComponent final : public USolarBaseDynamicMeshComponent
{
public:
	float                                         TraceUpOffset;                                     // 0x08B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceDownOffset;                                   // 0x08BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BoxTessellationLevel;                              // 0x08C0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InitBoxExtends;                                    // 0x08CC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TessellationDensity;                               // 0x08D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8DC[0x14];                                     // 0x08DC(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SolarTrapGrenadeDynamicMeshComponent">();
	}
	static class USolarTrapGrenadeDynamicMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USolarTrapGrenadeDynamicMeshComponent>();
	}
};
static_assert(alignof(USolarTrapGrenadeDynamicMeshComponent) == 0x000010, "Wrong alignment on USolarTrapGrenadeDynamicMeshComponent");
static_assert(sizeof(USolarTrapGrenadeDynamicMeshComponent) == 0x0008F0, "Wrong size on USolarTrapGrenadeDynamicMeshComponent");
static_assert(offsetof(USolarTrapGrenadeDynamicMeshComponent, TraceUpOffset) == 0x0008B8, "Member 'USolarTrapGrenadeDynamicMeshComponent::TraceUpOffset' has a wrong offset!");
static_assert(offsetof(USolarTrapGrenadeDynamicMeshComponent, TraceDownOffset) == 0x0008BC, "Member 'USolarTrapGrenadeDynamicMeshComponent::TraceDownOffset' has a wrong offset!");
static_assert(offsetof(USolarTrapGrenadeDynamicMeshComponent, BoxTessellationLevel) == 0x0008C0, "Member 'USolarTrapGrenadeDynamicMeshComponent::BoxTessellationLevel' has a wrong offset!");
static_assert(offsetof(USolarTrapGrenadeDynamicMeshComponent, InitBoxExtends) == 0x0008CC, "Member 'USolarTrapGrenadeDynamicMeshComponent::InitBoxExtends' has a wrong offset!");
static_assert(offsetof(USolarTrapGrenadeDynamicMeshComponent, TessellationDensity) == 0x0008D8, "Member 'USolarTrapGrenadeDynamicMeshComponent::TessellationDensity' has a wrong offset!");

// Class RuntimeGeometryUtils.DynamicPMCActor
// 0x0008 (0x0650 - 0x0648)
class ADynamicPMCActor final : public ADynamicMeshBaseActor
{
public:
	class UProceduralMeshComponent*               MeshComponent;                                     // 0x0648(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicPMCActor">();
	}
	static class ADynamicPMCActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADynamicPMCActor>();
	}
};
static_assert(alignof(ADynamicPMCActor) == 0x000008, "Wrong alignment on ADynamicPMCActor");
static_assert(sizeof(ADynamicPMCActor) == 0x000650, "Wrong size on ADynamicPMCActor");
static_assert(offsetof(ADynamicPMCActor, MeshComponent) == 0x000648, "Member 'ADynamicPMCActor::MeshComponent' has a wrong offset!");

// Class RuntimeGeometryUtils.DynamicSDMCActor
// 0x0008 (0x0650 - 0x0648)
class ADynamicSDMCActor final : public ADynamicMeshBaseActor
{
public:
	class USimpleDynamicMeshComponent*            MeshComponent;                                     // 0x0648(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicSDMCActor">();
	}
	static class ADynamicSDMCActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADynamicSDMCActor>();
	}
};
static_assert(alignof(ADynamicSDMCActor) == 0x000008, "Wrong alignment on ADynamicSDMCActor");
static_assert(sizeof(ADynamicSDMCActor) == 0x000650, "Wrong size on ADynamicSDMCActor");
static_assert(offsetof(ADynamicSDMCActor, MeshComponent) == 0x000648, "Member 'ADynamicSDMCActor::MeshComponent' has a wrong offset!");

// Class RuntimeGeometryUtils.DynamicSMCActor
// 0x0010 (0x0658 - 0x0648)
class ADynamicSMCActor final : public ADynamicMeshBaseActor
{
public:
	class UStaticMeshComponent*                   MeshComponent;                                     // 0x0648(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            StaticMesh;                                        // 0x0650(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicSMCActor">();
	}
	static class ADynamicSMCActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADynamicSMCActor>();
	}
};
static_assert(alignof(ADynamicSMCActor) == 0x000008, "Wrong alignment on ADynamicSMCActor");
static_assert(sizeof(ADynamicSMCActor) == 0x000658, "Wrong size on ADynamicSMCActor");
static_assert(offsetof(ADynamicSMCActor, MeshComponent) == 0x000648, "Member 'ADynamicSMCActor::MeshComponent' has a wrong offset!");
static_assert(offsetof(ADynamicSMCActor, StaticMesh) == 0x000650, "Member 'ADynamicSMCActor::StaticMesh' has a wrong offset!");

// Class RuntimeGeometryUtils.SolarWallDynamicMeshComponent
// 0x0100 (0x09C0 - 0x08C0)
class USolarWallDynamicMeshComponent final : public USolarBaseDynamicMeshComponent
{
public:
	float                                         TraceOffset;                                       // 0x08B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeedDrawDebugLine;                                // 0x08BC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWave;                                             // 0x08BD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8BE[0x2];                                      // 0x08BE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ZOffset;                                           // 0x08C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAxis                                         ForwardAxis;                                       // 0x08C4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C5[0x3];                                      // 0x08C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TessellationDensity;                               // 0x08C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InitBoxExtends;                                    // 0x08CC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BoxOrigin;                                         // 0x08D8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BoxTessellationLevel;                              // 0x08E4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MaxBoxExtend;                                      // 0x08F0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BoxExtendSpeed;                                    // 0x08FC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartTimeFromBeginPlay;                            // 0x0908(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDynamicMeshWallMoveDirection                 BoxMoveDirection;                                  // 0x090C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_90D[0x3];                                      // 0x090D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ZDeltaScale;                                       // 0x0910(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDynamicMeshGeneratorType                     GeneratorType;                                     // 0x0914(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_915[0xAB];                                     // 0x0915(0x00AB)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SolarWallDynamicMeshComponent">();
	}
	static class USolarWallDynamicMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USolarWallDynamicMeshComponent>();
	}
};
static_assert(alignof(USolarWallDynamicMeshComponent) == 0x000010, "Wrong alignment on USolarWallDynamicMeshComponent");
static_assert(sizeof(USolarWallDynamicMeshComponent) == 0x0009C0, "Wrong size on USolarWallDynamicMeshComponent");
static_assert(offsetof(USolarWallDynamicMeshComponent, TraceOffset) == 0x0008B8, "Member 'USolarWallDynamicMeshComponent::TraceOffset' has a wrong offset!");
static_assert(offsetof(USolarWallDynamicMeshComponent, bNeedDrawDebugLine) == 0x0008BC, "Member 'USolarWallDynamicMeshComponent::bNeedDrawDebugLine' has a wrong offset!");
static_assert(offsetof(USolarWallDynamicMeshComponent, bWave) == 0x0008BD, "Member 'USolarWallDynamicMeshComponent::bWave' has a wrong offset!");
static_assert(offsetof(USolarWallDynamicMeshComponent, ZOffset) == 0x0008C0, "Member 'USolarWallDynamicMeshComponent::ZOffset' has a wrong offset!");
static_assert(offsetof(USolarWallDynamicMeshComponent, ForwardAxis) == 0x0008C4, "Member 'USolarWallDynamicMeshComponent::ForwardAxis' has a wrong offset!");
static_assert(offsetof(USolarWallDynamicMeshComponent, TessellationDensity) == 0x0008C8, "Member 'USolarWallDynamicMeshComponent::TessellationDensity' has a wrong offset!");
static_assert(offsetof(USolarWallDynamicMeshComponent, InitBoxExtends) == 0x0008CC, "Member 'USolarWallDynamicMeshComponent::InitBoxExtends' has a wrong offset!");
static_assert(offsetof(USolarWallDynamicMeshComponent, BoxOrigin) == 0x0008D8, "Member 'USolarWallDynamicMeshComponent::BoxOrigin' has a wrong offset!");
static_assert(offsetof(USolarWallDynamicMeshComponent, BoxTessellationLevel) == 0x0008E4, "Member 'USolarWallDynamicMeshComponent::BoxTessellationLevel' has a wrong offset!");
static_assert(offsetof(USolarWallDynamicMeshComponent, MaxBoxExtend) == 0x0008F0, "Member 'USolarWallDynamicMeshComponent::MaxBoxExtend' has a wrong offset!");
static_assert(offsetof(USolarWallDynamicMeshComponent, BoxExtendSpeed) == 0x0008FC, "Member 'USolarWallDynamicMeshComponent::BoxExtendSpeed' has a wrong offset!");
static_assert(offsetof(USolarWallDynamicMeshComponent, StartTimeFromBeginPlay) == 0x000908, "Member 'USolarWallDynamicMeshComponent::StartTimeFromBeginPlay' has a wrong offset!");
static_assert(offsetof(USolarWallDynamicMeshComponent, BoxMoveDirection) == 0x00090C, "Member 'USolarWallDynamicMeshComponent::BoxMoveDirection' has a wrong offset!");
static_assert(offsetof(USolarWallDynamicMeshComponent, ZDeltaScale) == 0x000910, "Member 'USolarWallDynamicMeshComponent::ZDeltaScale' has a wrong offset!");
static_assert(offsetof(USolarWallDynamicMeshComponent, GeneratorType) == 0x000914, "Member 'USolarWallDynamicMeshComponent::GeneratorType' has a wrong offset!");

}

