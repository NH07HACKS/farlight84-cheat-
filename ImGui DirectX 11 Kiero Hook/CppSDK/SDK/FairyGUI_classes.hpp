#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: FairyGUI

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Engine_classes.hpp"
#include "FairyGUI_structs.hpp"


namespace SDK
{

// Class FairyGUI.DragDropManager
// 0x0020 (0x0048 - 0x0028)
class UDragDropManager final : public UObject
{
public:
	class UGLoader*                               Agent;                                             // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cancel();
	void StartDrag(const class FString& InIcon, const struct FNVariant& InUserData, int32 InUserIndex, int32 InPointerIndex);

	class UGLoader* GetAgent() const;
	bool IsDragging() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DragDropManager">();
	}
	static class UDragDropManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDragDropManager>();
	}
};
static_assert(alignof(UDragDropManager) == 0x000008, "Wrong alignment on UDragDropManager");
static_assert(sizeof(UDragDropManager) == 0x000048, "Wrong size on UDragDropManager");
static_assert(offsetof(UDragDropManager, Agent) == 0x000028, "Member 'UDragDropManager::Agent' has a wrong offset!");

// Class FairyGUI.EventContext
// 0x0050 (0x0078 - 0x0028)
class UEventContext final : public UObject
{
public:
	uint8                                         Pad_28[0x50];                                      // 0x0028(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CaptureTouch();
	void PreventDefault();
	void StopPropagation();

	int32 GetClickCount() const;
	const struct FNVariant GetData() const;
	class UGObject* GetInitiator() const;
	struct FKeyEvent GetKeyEvent() const;
	struct FKey GetMouseButton() const;
	struct FPointerEvent GetPointerEvent() const;
	int32 GetPointerIndex() const;
	const struct FVector2D GetPointerPosition() const;
	class UGObject* GetSender() const;
	const class FName GetType() const;
	int32 GetUserIndex() const;
	float GetWheelDelta() const;
	bool IsDefaultPrevented() const;
	bool IsDoubleClick() const;
	bool IsPropagationStopped() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventContext">();
	}
	static class UEventContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventContext>();
	}
};
static_assert(alignof(UEventContext) == 0x000008, "Wrong alignment on UEventContext");
static_assert(sizeof(UEventContext) == 0x000078, "Wrong size on UEventContext");

// Class FairyGUI.FairyApplication
// 0x0098 (0x00C0 - 0x0028)
class UFairyApplication final : public UObject
{
public:
	class UGRoot*                                 UIRoot;                                            // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDragDropManager*                       DragDropManager;                                   // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UEventContext*>                  EventContextPool;                                  // 0x0038(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48[0x78];                                      // 0x0048(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UFairyApplication* Get(class UObject* WorldContextObject);

	void CancelClick(int32 InUserIndex, int32 InPointerIndex);
	class UGObject* GetObjectUnderPoint(const struct FVector2D& ScreenspacePosition);
	struct FVector2D GetTouchPosition(int32 InUserIndex, int32 InPointerIndex);
	void PlaySound(const class FString& URL, float VolumeScale);
	void SetSoundEnabled(bool InEnabled);
	void SetSoundVolumeScale(float InVolumeScale);

	class UDragDropManager* GetDragDropManager() const;
	float GetSoundVolumeScale() const;
	int32 GetTouchCount() const;
	class UGRoot* GetUIRoot() const;
	bool IsSoundEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FairyApplication">();
	}
	static class UFairyApplication* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFairyApplication>();
	}
};
static_assert(alignof(UFairyApplication) == 0x000008, "Wrong alignment on UFairyApplication");
static_assert(sizeof(UFairyApplication) == 0x0000C0, "Wrong size on UFairyApplication");
static_assert(offsetof(UFairyApplication, UIRoot) == 0x000028, "Member 'UFairyApplication::UIRoot' has a wrong offset!");
static_assert(offsetof(UFairyApplication, DragDropManager) == 0x000030, "Member 'UFairyApplication::DragDropManager' has a wrong offset!");
static_assert(offsetof(UFairyApplication, EventContextPool) == 0x000038, "Member 'UFairyApplication::EventContextPool' has a wrong offset!");

// Class FairyGUI.FairyBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UFairyBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static const struct FUIConfig GetUIConfig();
	static bool GetVariantAsBool(struct FNVariant& InVariant);
	static struct FColor GetVariantAsColor(struct FNVariant& InVariant);
	static float GetVariantAsFloat(struct FNVariant& InVariant);
	static int32 GetVariantAsInt(struct FNVariant& InVariant);
	static class FString GetVariantAsString(struct FNVariant& InVariant);
	static class UObject* GetVariantAsUObject(struct FNVariant& InVariant, TSubclassOf<class UObject> ClassType);
	static void KillTween(struct FTweenerHandle& Handle, bool bSetComplete);
	static void SetPackageItemExtension(const class FString& URL, TSubclassOf<class UGComponent> ClassType);
	static void SetUIConfig(const struct FUIConfig& InConfig);
	static struct FNVariant SetVariantBool(struct FNVariant& InVariant, bool bInValue);
	static struct FNVariant SetVariantColor(struct FNVariant& InVariant, const struct FColor& InValue);
	static struct FNVariant SetVariantFloat(struct FNVariant& InVariant, float InValue);
	static struct FNVariant SetVariantInt(struct FNVariant& InVariant, int32 InValue);
	static struct FNVariant SetVariantString(struct FNVariant& InVariant, const class FString& InValue);
	static struct FNVariant SetVariantUObject(struct FNVariant& InVariant, class UObject* InValue);
	static struct FTweenerHandle TweenFloat(float StartValue, float EndValue, EEaseType EaseType, float Duration, int32 Repeat, const TDelegate<void(const struct FTweenValue& Value, const struct FTweenValue& DeltaValue)>& OnUpdate, const TDelegate<void()>& OnComplete);
	static struct FTweenerHandle TweenVector2(const struct FVector2D& StartValue, const struct FVector2D& EndValue, EEaseType EaseType, float Duration, int32 Repeat, const TDelegate<void(const struct FTweenValue& Value, const struct FTweenValue& DeltaValue)>& OnUpdate, const TDelegate<void()>& OnComplete);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FairyBlueprintLibrary">();
	}
	static class UFairyBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFairyBlueprintLibrary>();
	}
};
static_assert(alignof(UFairyBlueprintLibrary) == 0x000008, "Wrong alignment on UFairyBlueprintLibrary");
static_assert(sizeof(UFairyBlueprintLibrary) == 0x000028, "Wrong size on UFairyBlueprintLibrary");

// Class FairyGUI.GObject
// 0x0318 (0x0340 - 0x0028)
class UGObject : public UObject
{
public:
	TMulticastInlineDelegate<void(class UEventContext* EventContext)> OnClick;                       // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UEventContext* EventContext)> OnTouchBegin;                  // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UEventContext* EventContext)> OnTouchMove;                   // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UEventContext* EventContext)> OnTouchEnd;                    // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UEventContext* EventContext)> OnRollOver;                    // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UEventContext* EventContext)> OnRollOut;                     // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UEventContext* EventContext)> OnDragStart;                   // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UEventContext* EventContext)> OnDragMove;                    // 0x0098(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UEventContext* EventContext)> OnDragEnd;                     // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UEventContext* EventContext)> OnGearStop;                    // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UEventContext* EventContext)> OnAddedToStage;                // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UEventContext* EventContext)> OnRemovedFromStage;            // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FString                                 ID;                                                // 0x00E8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Name_0;                                            // 0x00F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              SourceSize;                                        // 0x0108(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              InitSize;                                          // 0x0110(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              MinSize;                                           // 0x0118(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              MaxSize;                                           // 0x0120(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FNVariant                              UserData;                                          // 0x0128(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_140[0x200];                                    // 0x0140(0x0200)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UGObject* GetDraggingObject();

	void AddRelation(class UGObject* Obj, ERelationType RelationType, bool bUsePercent);
	void Center(bool bRestraint);
	struct FVector2D GlobalToLocal(const struct FVector2D& InPoint);
	struct FBox2D GlobalToLocalRect(const struct FBox2D& InRect);
	struct FVector2D LocalToGlobal(const struct FVector2D& InPoint);
	struct FBox2D LocalToGlobalRect(const struct FBox2D& InRect);
	struct FVector2D LocalToRoot(const struct FVector2D& InPoint);
	struct FBox2D LocalToRootRect(const struct FBox2D& InRect);
	void MakeFullScreen(bool bRestraint);
	void OnRollOutHandler(class UEventContext* Context);
	void OnRollOverHandler(class UEventContext* Context);
	void OnTouchBeginHandler(class UEventContext* Context);
	void OnTouchEndHandler(class UEventContext* Context);
	void OnTouchMoveHandler(class UEventContext* Context);
	void RemoveFromParent();
	void RemoveRelation(class UGObject* Obj, ERelationType RelationType);
	struct FVector2D RootToLocal(const struct FVector2D& InPoint);
	struct FBox2D RootToLocalRect(const struct FBox2D& InRect);
	void SetAlpha(float InAlpha);
	void SetDragBounds(const struct FBox2D& InBounds);
	void SetDraggable(bool bInDraggable);
	void SetGrayed(bool bInGrayed);
	void SetGroup(class UGGroup* InGroup);
	void SetHeight(float InHeight);
	void SetIcon(const class FString& InIcon);
	void SetParent(class UGObject* InParent);
	void SetParentToRoot();
	void SetPivot(const struct FVector2D& InPivot, bool bAsAnchor);
	void SetPosition(const struct FVector2D& InPosition);
	void SetRotation(float InRotation);
	void SetScale(const struct FVector2D& InScale);
	void SetScaleX(float InScaleX);
	void SetScaleY(float InScaleY);
	void SetSize(const struct FVector2D& InSize, bool bIgnorePivot);
	void SetSkew(const struct FVector2D& InSkew);
	void SetSortingOrder(int32 InSortingOrder);
	void SetText(const class FString& InText);
	void SetTooltips(const class FString& InTooltips);
	void SetTouchable(bool bInTouchable);
	void SetVisible(bool bInVisible);
	void SetWidth(float InWidth);
	void SetX(float InX);
	void SetXMin(float InXMin);
	void SetY(float InY);
	void SetYMin(float InYMin);
	void StartDrag(int32 UserIndex, int32 PointerIndex);
	void StopDrag();

	class UGObject* CastTo(TSubclassOf<class UGObject> ClassType) const;
	float GetAlpha() const;
	class UFairyApplication* GetApp() const;
	struct FBox2D GetDragBounds() const;
	class UGGroup* GetGroup() const;
	float GetHeight() const;
	class FString GetIcon() const;
	class FString GetPackageName() const;
	class UGComponent* GetParent() const;
	const struct FVector2D GetPivot() const;
	const struct FVector2D GetPosition() const;
	class FString GetResourceName() const;
	class FString GetResourceURL() const;
	float GetRotation() const;
	const struct FVector2D GetScale() const;
	float GetScaleX() const;
	float GetScaleY() const;
	const struct FVector2D GetSize() const;
	const struct FVector2D GetSkew() const;
	int32 GetSortingOrder() const;
	class FString GetText() const;
	class FString GetTooltips() const;
	class UGTreeNode* GetTreeNode() const;
	class UGRoot* GetUIRoot() const;
	float GetWidth() const;
	float GetX() const;
	float GetXMin() const;
	float GetY() const;
	float GetYMin() const;
	bool IsDraggable() const;
	bool IsGrayed() const;
	bool IsPivotAsAnchor() const;
	bool IsTouchable() const;
	bool IsVisible() const;
	bool OnStage() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GObject">();
	}
	static class UGObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGObject>();
	}
};
static_assert(alignof(UGObject) == 0x000008, "Wrong alignment on UGObject");
static_assert(sizeof(UGObject) == 0x000340, "Wrong size on UGObject");
static_assert(offsetof(UGObject, OnClick) == 0x000028, "Member 'UGObject::OnClick' has a wrong offset!");
static_assert(offsetof(UGObject, OnTouchBegin) == 0x000038, "Member 'UGObject::OnTouchBegin' has a wrong offset!");
static_assert(offsetof(UGObject, OnTouchMove) == 0x000048, "Member 'UGObject::OnTouchMove' has a wrong offset!");
static_assert(offsetof(UGObject, OnTouchEnd) == 0x000058, "Member 'UGObject::OnTouchEnd' has a wrong offset!");
static_assert(offsetof(UGObject, OnRollOver) == 0x000068, "Member 'UGObject::OnRollOver' has a wrong offset!");
static_assert(offsetof(UGObject, OnRollOut) == 0x000078, "Member 'UGObject::OnRollOut' has a wrong offset!");
static_assert(offsetof(UGObject, OnDragStart) == 0x000088, "Member 'UGObject::OnDragStart' has a wrong offset!");
static_assert(offsetof(UGObject, OnDragMove) == 0x000098, "Member 'UGObject::OnDragMove' has a wrong offset!");
static_assert(offsetof(UGObject, OnDragEnd) == 0x0000A8, "Member 'UGObject::OnDragEnd' has a wrong offset!");
static_assert(offsetof(UGObject, OnGearStop) == 0x0000B8, "Member 'UGObject::OnGearStop' has a wrong offset!");
static_assert(offsetof(UGObject, OnAddedToStage) == 0x0000C8, "Member 'UGObject::OnAddedToStage' has a wrong offset!");
static_assert(offsetof(UGObject, OnRemovedFromStage) == 0x0000D8, "Member 'UGObject::OnRemovedFromStage' has a wrong offset!");
static_assert(offsetof(UGObject, ID) == 0x0000E8, "Member 'UGObject::ID' has a wrong offset!");
static_assert(offsetof(UGObject, Name_0) == 0x0000F8, "Member 'UGObject::Name_0' has a wrong offset!");
static_assert(offsetof(UGObject, SourceSize) == 0x000108, "Member 'UGObject::SourceSize' has a wrong offset!");
static_assert(offsetof(UGObject, InitSize) == 0x000110, "Member 'UGObject::InitSize' has a wrong offset!");
static_assert(offsetof(UGObject, MinSize) == 0x000118, "Member 'UGObject::MinSize' has a wrong offset!");
static_assert(offsetof(UGObject, MaxSize) == 0x000120, "Member 'UGObject::MaxSize' has a wrong offset!");
static_assert(offsetof(UGObject, UserData) == 0x000128, "Member 'UGObject::UserData' has a wrong offset!");

// Class FairyGUI.GComponent
// 0x0108 (0x0448 - 0x0340)
class UGComponent : public UGObject
{
public:
	TMulticastInlineDelegate<void(class UEventContext* EventContext)> OnDrop;                        // 0x0340(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UEventContext* EventContext)> OnScroll;                      // 0x0350(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UEventContext* EventContext)> OnScrollEnd;                   // 0x0360(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UEventContext* EventContext)> OnPullUpRelease;               // 0x0370(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UEventContext* EventContext)> OnPullDownRelease;             // 0x0380(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_390[0x8];                                      // 0x0390(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UGObject*>                       Children;                                          // 0x0398(0x0010)(ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UGController*>                   Controllers;                                       // 0x03A8(0x0010)(ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UTransition*>                    Transitions;                                       // 0x03B8(0x0010)(ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScrollPane*                            ScrollPane;                                        // 0x03C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D0[0x78];                                     // 0x03D0(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UGObject* AddChild(class UGObject* Child);
	class UGObject* AddChildAt(class UGObject* Child, int32 Index_0);
	void EnsureBoundsCorrect();
	const struct FMargin GetMargin();
	void K2_OnConstruct();
	void OnClickChild(const class FString& ChildName, const TDelegate<void(class UEventContext* EventContext)>& Delegate);
	void RemoveChild(class UGObject* Child);
	void RemoveChildAt(int32 Index_0);
	void RemoveChildren(int32 BeginIndex, int32 EndIndex);
	void SetApexIndex(int32 InApedIndex);
	void SetBoundsChangedFlag();
	void SetChildIndex(class UGObject* Child, int32 Index_0);
	int32 SetChildIndexBefore(class UGObject* Child, int32 Index_0);
	void SetChildrenRenderOrder(EChildrenRenderOrder InChildrenRenderOrder);
	void SetMargin(const struct FMargin& InMargin);
	void SetOpaque(bool bInOpaque);
	void SetViewHeight(float InViewHeight);
	void SetViewWidth(float InViewWidth);
	void SwapChildren(class UGObject* Child1, class UGObject* Child2);
	void SwapChildrenAt(int32 Index1, int32 Index2);

	int32 GetApexIndex() const;
	class UGObject* GetChild(const class FString& ChildName, TSubclassOf<class UGObject> ClassType) const;
	class UGObject* GetChildAt(int32 Index_0, TSubclassOf<class UGObject> ClassType) const;
	class UGObject* GetChildByPath(const class FString& Path, TSubclassOf<class UGObject> ClassType) const;
	int32 GetChildIndex(const class UGObject* Child) const;
	class UGObject* GetChildInGroup(const class UGGroup* Group, const class FString& ChildName, TSubclassOf<class UGObject> ClassType) const;
	EChildrenRenderOrder GetChildrenRenderOrder() const;
	class UGController* GetController(const class FString& ControllerName) const;
	class UGController* GetControllerAt(int32 Index_0) const;
	int32 GetFirstChildInView() const;
	class UScrollPane* GetScrollPane() const;
	class UTransition* GetTransition(const class FString& TransitionName) const;
	class UTransition* GetTransitionAt(int32 Index_0) const;
	float GetViewHeight() const;
	float GetViewWidth() const;
	bool IsAncestorOf(const class UGObject* Obj) const;
	bool IsChildInView(class UGObject* Child) const;
	bool IsOpaque() const;
	int32 NumChildren() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GComponent">();
	}
	static class UGComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGComponent>();
	}
};
static_assert(alignof(UGComponent) == 0x000008, "Wrong alignment on UGComponent");
static_assert(sizeof(UGComponent) == 0x000448, "Wrong size on UGComponent");
static_assert(offsetof(UGComponent, OnDrop) == 0x000340, "Member 'UGComponent::OnDrop' has a wrong offset!");
static_assert(offsetof(UGComponent, OnScroll) == 0x000350, "Member 'UGComponent::OnScroll' has a wrong offset!");
static_assert(offsetof(UGComponent, OnScrollEnd) == 0x000360, "Member 'UGComponent::OnScrollEnd' has a wrong offset!");
static_assert(offsetof(UGComponent, OnPullUpRelease) == 0x000370, "Member 'UGComponent::OnPullUpRelease' has a wrong offset!");
static_assert(offsetof(UGComponent, OnPullDownRelease) == 0x000380, "Member 'UGComponent::OnPullDownRelease' has a wrong offset!");
static_assert(offsetof(UGComponent, Children) == 0x000398, "Member 'UGComponent::Children' has a wrong offset!");
static_assert(offsetof(UGComponent, Controllers) == 0x0003A8, "Member 'UGComponent::Controllers' has a wrong offset!");
static_assert(offsetof(UGComponent, Transitions) == 0x0003B8, "Member 'UGComponent::Transitions' has a wrong offset!");
static_assert(offsetof(UGComponent, ScrollPane) == 0x0003C8, "Member 'UGComponent::ScrollPane' has a wrong offset!");

// Class FairyGUI.GButton
// 0x00B0 (0x04F8 - 0x0448)
class UGButton final : public UGComponent
{
public:
	TMulticastInlineDelegate<void(class UEventContext* EventContext)> OnChanged;                     // 0x0448(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bChangeStateOnClick;                               // 0x0458(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_459[0x9F];                                     // 0x0459(0x009F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetRelatedController(class UGController* InController);
	void SetSelected(bool bInSelected);
	void SetSelectedIcon(const class FString& InIcon);
	void SetSelectedTitle(const class FString& InTitle);
	void SetTitle(const class FString& InTitle);
	void SetTitleColor(const struct FColor& InColor);
	void SetTitleFontSize(int32 InFontSize);

	class UGController* GetRelatedController() const;
	class FString GetSelectedIcon() const;
	class FString GetSelectedTitle() const;
	class FString GetTitle() const;
	struct FColor GetTitleColor() const;
	int32 GetTitleFontSize() const;
	bool IsSelected() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GButton">();
	}
	static class UGButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGButton>();
	}
};
static_assert(alignof(UGButton) == 0x000008, "Wrong alignment on UGButton");
static_assert(sizeof(UGButton) == 0x0004F8, "Wrong size on UGButton");
static_assert(offsetof(UGButton, OnChanged) == 0x000448, "Member 'UGButton::OnChanged' has a wrong offset!");
static_assert(offsetof(UGButton, bChangeStateOnClick) == 0x000458, "Member 'UGButton::bChangeStateOnClick' has a wrong offset!");

// Class FairyGUI.GComboBox
// 0x0088 (0x04D0 - 0x0448)
class UGComboBox final : public UGComponent
{
public:
	int32                                         VisibleItemCount;                                  // 0x0448(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPopupDirection                               PopupDirection;                                    // 0x044C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44D[0x3];                                      // 0x044D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         Items;                                             // 0x0450(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         Icons;                                             // 0x0460(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         Values;                                            // 0x0470(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UEventContext* EventContext)> OnChanged;                     // 0x0480(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UGComponent*                            DropdownObject;                                    // 0x0490(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_498[0x38];                                     // 0x0498(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Refresh();
	void SetSelectedIndex(int32 InIndex);
	void SetSelectionController(class UGController* InController);
	void SetTitle(const class FString& InTitle);
	void SetTitleColor(const struct FColor& InColor);
	void SetTitleFontSize(int32 InFontSize);
	void SetValue(const class FString& InValue);

	class UGObject* GetDropdown() const;
	int32 GetSelectedIndex() const;
	class UGController* GetSelectionController() const;
	class FString GetTitle() const;
	struct FColor GetTitleColor() const;
	int32 GetTitleFontSize() const;
	class FString GetValue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GComboBox">();
	}
	static class UGComboBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGComboBox>();
	}
};
static_assert(alignof(UGComboBox) == 0x000008, "Wrong alignment on UGComboBox");
static_assert(sizeof(UGComboBox) == 0x0004D0, "Wrong size on UGComboBox");
static_assert(offsetof(UGComboBox, VisibleItemCount) == 0x000448, "Member 'UGComboBox::VisibleItemCount' has a wrong offset!");
static_assert(offsetof(UGComboBox, PopupDirection) == 0x00044C, "Member 'UGComboBox::PopupDirection' has a wrong offset!");
static_assert(offsetof(UGComboBox, Items) == 0x000450, "Member 'UGComboBox::Items' has a wrong offset!");
static_assert(offsetof(UGComboBox, Icons) == 0x000460, "Member 'UGComboBox::Icons' has a wrong offset!");
static_assert(offsetof(UGComboBox, Values) == 0x000470, "Member 'UGComboBox::Values' has a wrong offset!");
static_assert(offsetof(UGComboBox, OnChanged) == 0x000480, "Member 'UGComboBox::OnChanged' has a wrong offset!");
static_assert(offsetof(UGComboBox, DropdownObject) == 0x000490, "Member 'UGComboBox::DropdownObject' has a wrong offset!");

// Class FairyGUI.GController
// 0x0068 (0x0090 - 0x0028)
class UGController final : public UObject
{
public:
	uint8                                         Pad_28[0x68];                                      // 0x0028(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetSelectedIndex(int32 Index_0);
	void SetSelectedPage(const class FString& PageName);

	int32 GetSelectedIndex() const;
	class FString GetSelectedPage() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GController">();
	}
	static class UGController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGController>();
	}
};
static_assert(alignof(UGController) == 0x000008, "Wrong alignment on UGController");
static_assert(sizeof(UGController) == 0x000090, "Wrong size on UGController");

// Class FairyGUI.GGraph
// 0x0010 (0x0350 - 0x0340)
class UGGraph final : public UGObject
{
public:
	uint8                                         Pad_340[0x10];                                     // 0x0340(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Clear();
	void DrawEllipse(float LineWidth, const struct FColor& LineColor, const struct FColor& FillColor, float StartDegree, float EndDegree);
	void DrawPolygon(float LineWidth, const struct FColor& LineColor, const struct FColor& FillColor, const TArray<struct FVector2D>& Points);
	void DrawRect(float LineWidth, const struct FColor& LineColor, const struct FColor& FillColor);
	void DrawRegularPolygon(int32 Sides, float LineWidth, const struct FColor& LineColor, const struct FColor& FillColor, float Rotation, const TArray<float>& Distances);
	void DrawRoundRect(float LineWidth, const struct FColor& LineColor, const struct FColor& FillColor, float TopLeftRadius, float TopRightRadius, float BottomLeftRadius, float BottomRightRadius);
	void SetColor(const struct FColor& InColor);

	struct FColor GetColor() const;
	bool IsEmpty() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GGraph">();
	}
	static class UGGraph* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGGraph>();
	}
};
static_assert(alignof(UGGraph) == 0x000008, "Wrong alignment on UGGraph");
static_assert(sizeof(UGGraph) == 0x000350, "Wrong size on UGGraph");

// Class FairyGUI.GGroup
// 0x0030 (0x0370 - 0x0340)
class UGGroup final : public UGObject
{
public:
	uint8                                         Pad_340[0x30];                                     // 0x0340(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EnsureBoundsCorrect();
	int32 GetColumnGap();
	EGroupLayoutType GetLayout();
	int32 GetLineGap();
	int32 GetMainGridIndex();
	int32 GetMainGridMinSize();
	bool IsAutoSizeDisabled();
	bool IsExcludeInvisibles();
	void SetAutoSizeDisabled(bool bInFlag);
	void SetBoundsChangedFlag(bool bPositionChangedOnly);
	void SetColumnGap(int32 InColumnGap);
	void SetExcludeInvisibles(bool bInFlag);
	void SetLayout(EGroupLayoutType InLayout);
	void SetLineGap(int32 InLineGap);
	void SetMainGridIndex(int32 InIndex);
	void SetMainGridMinSize(int32 InSize);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GGroup">();
	}
	static class UGGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGGroup>();
	}
};
static_assert(alignof(UGGroup) == 0x000008, "Wrong alignment on UGGroup");
static_assert(sizeof(UGGroup) == 0x000370, "Wrong size on UGGroup");

// Class FairyGUI.GImage
// 0x0010 (0x0350 - 0x0340)
class UGImage final : public UGObject
{
public:
	uint8                                         Pad_340[0x10];                                     // 0x0340(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetColor(const struct FColor& InColor);
	void SetFillAmount(float amount);
	void SetFillClockwise(bool bClockwise);
	void SetFillMethod(EFillMethod Method);
	void SetFillOrigin(int32 Origin);
	void SetFlip(EFlipType InFlip);

	struct FColor GetColor() const;
	float GetFillAmount() const;
	EFillMethod GetFillMethod() const;
	int32 GetFillOrigin() const;
	EFlipType GetFlip() const;
	bool IsFillClockwise() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GImage">();
	}
	static class UGImage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGImage>();
	}
};
static_assert(alignof(UGImage) == 0x000008, "Wrong alignment on UGImage");
static_assert(sizeof(UGImage) == 0x000350, "Wrong size on UGImage");

// Class FairyGUI.GLabel
// 0x0010 (0x0458 - 0x0448)
class UGLabel final : public UGComponent
{
public:
	uint8                                         Pad_448[0x10];                                     // 0x0448(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetTitle(const class FString& InTitle);
	void SetTitleColor(const struct FColor& InColor);
	void SetTitleFontSize(int32 Value);

	class FString GetTitle() const;
	struct FColor GetTitleColor() const;
	int32 GetTitleFontSize() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GLabel">();
	}
	static class UGLabel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGLabel>();
	}
};
static_assert(alignof(UGLabel) == 0x000008, "Wrong alignment on UGLabel");
static_assert(sizeof(UGLabel) == 0x000458, "Wrong size on UGLabel");

// Class FairyGUI.GList
// 0x00B8 (0x0500 - 0x0448)
class UGList : public UGComponent
{
public:
	TMulticastInlineDelegate<void(class UEventContext* EventContext)> OnClickItem;                   // 0x0448(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bScrollItemToViewOnClick;                          // 0x0458(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFoldInvisibleItems;                               // 0x0459(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45A[0xA6];                                     // 0x045A(0x00A6)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UGObject* AddItemFromPool(const class FString& URL);
	void AddSelection(int32 Index_0, bool bScrollItToView);
	void ClearSelection();
	int32 GetColumnCount();
	void OnClickItemHandler(class UEventContext* Context);
	void RefreshVirtualList();
	void RemoveChildrenToPool(int32 BeginIndex, int32 EndIndex);
	void RemoveChildToPool(class UGObject* Child);
	void RemoveChildToPoolAt(int32 Index_0);
	void RemoveSelection(int32 Index_0);
	void ResizeToFit(int32 ItemCount, int32 InMinSize);
	void ScrollToView(int32 Index_0, bool bAnimation, bool bSetFirst);
	void SelectAll();
	void SelectReverse();
	void SetAlign(EAlignType InAlign);
	void SetAutoResizeItem(bool bFlag);
	void SetColumnCount(int32 InColumnCount);
	void SetColumnGap(int32 InColumnGap);
	void SetDefaultItem(const class FString& InDefaultItem);
	void SetItemProvider(const TDelegate<void(int32 Index)>& InItemProvider);
	void SetItemRenderer(const TDelegate<void(int32 Index, class UGObject* Obj)>& InItemRenderer);
	void SetLayout(EListLayoutType InLayout);
	void SetLineCount(int32 InLineCount);
	void SetLineGap(int32 InLineGap);
	void SetNumItems(int32 InNumItems);
	void SetSelectedIndex(int32 Index_0);
	void SetSelectionController(class UGController* InController);
	void SetSelectionMode(EListSelectionMode InMode);
	void SetVerticalAlign(EVerticalAlignType InVerticalAlign);
	void SetVirtual();
	void SetVirtualAndLoop();

	int32 ChildIndexToItemIndex(int32 Index_0) const;
	EAlignType GetAlign() const;
	bool GetAutoResizeItem() const;
	int32 GetColumnGap() const;
	class FString GetDefaultItem() const;
	EListLayoutType GetLayout() const;
	int32 GetLineCount() const;
	int32 GetLineGap() const;
	int32 GetNumItems() const;
	int32 GetSelectedIndex() const;
	class UGController* GetSelectionController() const;
	EListSelectionMode GetSelectionMode() const;
	EVerticalAlignType GetVerticalAlign() const;
	bool IsVirtual() const;
	int32 ItemIndexToChildIndex(int32 Index_0) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GList">();
	}
	static class UGList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGList>();
	}
};
static_assert(alignof(UGList) == 0x000008, "Wrong alignment on UGList");
static_assert(sizeof(UGList) == 0x000500, "Wrong size on UGList");
static_assert(offsetof(UGList, OnClickItem) == 0x000448, "Member 'UGList::OnClickItem' has a wrong offset!");
static_assert(offsetof(UGList, bScrollItemToViewOnClick) == 0x000458, "Member 'UGList::bScrollItemToViewOnClick' has a wrong offset!");
static_assert(offsetof(UGList, bFoldInvisibleItems) == 0x000459, "Member 'UGList::bFoldInvisibleItems' has a wrong offset!");

// Class FairyGUI.GLoader
// 0x0060 (0x03A0 - 0x0340)
class UGLoader final : public UGObject
{
public:
	uint8                                         Pad_340[0x30];                                     // 0x0340(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UGObject*                               Content2;                                          // 0x0370(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_378[0x28];                                     // 0x0378(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetAlign(EAlignType InAlign);
	void SetAutoSize(bool bInAutoSize);
	void SetColor(const struct FColor& InColor);
	void SetFill(ELoaderFillType InFillType);
	void SetFillAmount(float amount);
	void SetFillClockwise(bool bClockwise);
	void SetFillMethod(EFillMethod Method);
	void SetFillOrigin(int32 Origin);
	void SetFlip(EFlipType InFlip);
	void SetFrame(int32 InFrame);
	void SetPlaying(bool bInPlaying);
	void SetShrinkOnly(bool bInShrinkOnly);
	void SetURL(const class FString& InUrl);
	void SetVerticalAlign(EVerticalAlignType InVerticalAlign);

	EAlignType GetAlign() const;
	bool GetAutoSize() const;
	struct FColor GetColor() const;
	ELoaderFillType GetFill() const;
	float GetFillAmount() const;
	EFillMethod GetFillMethod() const;
	int32 GetFillOrigin() const;
	EFlipType GetFlip() const;
	int32 GetFrame() const;
	class FString GetUrl() const;
	EVerticalAlignType GetVerticalAlign() const;
	bool IsFillClockwise() const;
	bool IsPlaying() const;
	bool IsShrinkOnly() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GLoader">();
	}
	static class UGLoader* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGLoader>();
	}
};
static_assert(alignof(UGLoader) == 0x000008, "Wrong alignment on UGLoader");
static_assert(sizeof(UGLoader) == 0x0003A0, "Wrong size on UGLoader");
static_assert(offsetof(UGLoader, Content2) == 0x000370, "Member 'UGLoader::Content2' has a wrong offset!");

// Class FairyGUI.GLoader3D
// 0x0038 (0x0378 - 0x0340)
class UGLoader3D final : public UGObject
{
public:
	uint8                                         Pad_340[0x38];                                     // 0x0340(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetColor(const struct FColor& InColor);
	void SetURL(const class FString& InUrl);

	struct FColor GetColor() const;
	class FString GetUrl() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GLoader3D">();
	}
	static class UGLoader3D* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGLoader3D>();
	}
};
static_assert(alignof(UGLoader3D) == 0x000008, "Wrong alignment on UGLoader3D");
static_assert(sizeof(UGLoader3D) == 0x000378, "Wrong size on UGLoader3D");

// Class FairyGUI.GMovieClip
// 0x0010 (0x0350 - 0x0340)
class UGMovieClip final : public UGObject
{
public:
	uint8                                         Pad_340[0x10];                                     // 0x0340(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Advance(float Time);
	void SetColor(const struct FColor& InColor);
	void SetFlip(EFlipType InFlip);
	void SetFrame(int32 InFrame);
	void SetPlaying(bool bInPlaying);
	void SetPlaySettings(const TDelegate<void()>& InCompleteCallback, int32 InStart, int32 InEnd, int32 InTimes, int32 InEndAt);
	void SetTimeScale(float InTimeScale);

	struct FColor GetColor() const;
	EFlipType GetFlip() const;
	int32 GetFrame() const;
	float GetTimeScale() const;
	bool IsPlaying() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GMovieClip">();
	}
	static class UGMovieClip* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGMovieClip>();
	}
};
static_assert(alignof(UGMovieClip) == 0x000008, "Wrong alignment on UGMovieClip");
static_assert(sizeof(UGMovieClip) == 0x000350, "Wrong size on UGMovieClip");

// Class FairyGUI.GProgressBar
// 0x0048 (0x0490 - 0x0448)
class UGProgressBar final : public UGComponent
{
public:
	uint8                                         Pad_448[0x48];                                     // 0x0448(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetMax(float InMax);
	void SetMin(float InMin);
	void SetTitleType(EProgressTitleType InType);
	void SetValue(float InValue);
	void TweenValue(float InValue, float Duration);

	float GetMax() const;
	float GetMin() const;
	EProgressTitleType GetTitleType() const;
	float GetValue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GProgressBar">();
	}
	static class UGProgressBar* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGProgressBar>();
	}
};
static_assert(alignof(UGProgressBar) == 0x000008, "Wrong alignment on UGProgressBar");
static_assert(sizeof(UGProgressBar) == 0x000490, "Wrong size on UGProgressBar");

// Class FairyGUI.GTextField
// 0x0080 (0x03C0 - 0x0340)
class UGTextField : public UGObject
{
public:
	uint8                                         Pad_340[0x80];                                     // 0x0340(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyFormat();
	void FlushVars();
	struct FNTextFormat GetTextFormat();
	struct FVector2D GetTextSize();
	void SetAutoSize(EAutoSizeType InAutoSize);
	void SetSingleLine(bool InSingleLine);
	void SetTextFormat(const struct FNTextFormat& InTextFormat);
	void SetUBBEnabled(bool InEnabled);
	class UGTextField* SetVar(const class FString& VarKey, const class FString& VarValue);

	EAutoSizeType GetAutoSize() const;
	bool IsSingleLine() const;
	bool IsUBBEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GTextField">();
	}
	static class UGTextField* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGTextField>();
	}
};
static_assert(alignof(UGTextField) == 0x000008, "Wrong alignment on UGTextField");
static_assert(sizeof(UGTextField) == 0x0003C0, "Wrong size on UGTextField");

// Class FairyGUI.GRichTextField
// 0x0010 (0x03D0 - 0x03C0)
class UGRichTextField final : public UGTextField
{
public:
	TMulticastInlineDelegate<void(class UEventContext* EventContext)> OnClickLink;                   // 0x03C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GRichTextField">();
	}
	static class UGRichTextField* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGRichTextField>();
	}
};
static_assert(alignof(UGRichTextField) == 0x000008, "Wrong alignment on UGRichTextField");
static_assert(sizeof(UGRichTextField) == 0x0003D0, "Wrong size on UGRichTextField");
static_assert(offsetof(UGRichTextField, OnClickLink) == 0x0003C0, "Member 'UGRichTextField::OnClickLink' has a wrong offset!");

// Class FairyGUI.GRoot
// 0x0048 (0x0490 - 0x0448)
class UGRoot final : public UGComponent
{
public:
	class UGGraph*                                ModalLayer;                                        // 0x0448(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGObject*                               ModalWaitPane;                                     // 0x0450(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGObject*                               TooltipWin;                                        // 0x0458(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGObject*                               DefaultTooltipWin;                                 // 0x0460(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_468[0x28];                                     // 0x0468(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UGRoot* Get(class UObject* WorldContextObject);

	void BringToFront(class UGWindow* Window);
	void CloseAllExceptModals();
	void CloseAllWindows();
	void CloseModalWait();
	void HidePopup(class UGObject* Popup);
	void HideTooltips();
	void ShowModalWait();
	void ShowPopup(class UGObject* Popup, class UGObject* AtObject, EPopupDirection Direction);
	void ShowTooltips(const class FString& Text);
	void ShowTooltipsWin(class UGObject* InTooltipWin);
	void TogglePopup(class UGObject* Popup, class UGObject* AtObject, EPopupDirection Direction);

	class UGWindow* GetTopWindow() const;
	bool HasAnyPopup() const;
	bool HasModalWindow() const;
	bool IsModalWaiting() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GRoot">();
	}
	static class UGRoot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGRoot>();
	}
};
static_assert(alignof(UGRoot) == 0x000008, "Wrong alignment on UGRoot");
static_assert(sizeof(UGRoot) == 0x000490, "Wrong size on UGRoot");
static_assert(offsetof(UGRoot, ModalLayer) == 0x000448, "Member 'UGRoot::ModalLayer' has a wrong offset!");
static_assert(offsetof(UGRoot, ModalWaitPane) == 0x000450, "Member 'UGRoot::ModalWaitPane' has a wrong offset!");
static_assert(offsetof(UGRoot, TooltipWin) == 0x000458, "Member 'UGRoot::TooltipWin' has a wrong offset!");
static_assert(offsetof(UGRoot, DefaultTooltipWin) == 0x000460, "Member 'UGRoot::DefaultTooltipWin' has a wrong offset!");

// Class FairyGUI.GScrollBar
// 0x0048 (0x0490 - 0x0448)
class UGScrollBar final : public UGComponent
{
public:
	uint8                                         Pad_448[0x48];                                     // 0x0448(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GScrollBar">();
	}
	static class UGScrollBar* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGScrollBar>();
	}
};
static_assert(alignof(UGScrollBar) == 0x000008, "Wrong alignment on UGScrollBar");
static_assert(sizeof(UGScrollBar) == 0x000490, "Wrong size on UGScrollBar");

// Class FairyGUI.GSlider
// 0x0070 (0x04B8 - 0x0448)
class UGSlider final : public UGComponent
{
public:
	bool                                          bChangeOnClick;                                    // 0x0448(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanDrag;                                          // 0x0449(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44A[0x6];                                      // 0x044A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class UEventContext* EventContext)> OnChanged;                     // 0x0450(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_460[0x58];                                     // 0x0460(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetMax(float InMax);
	void SetMin(float InMin);
	void SetTitleType(EProgressTitleType InTitleType);
	void SetValue(float InValue);
	void SetWholeNumbers(bool bWholeNumbers);

	float GetMax() const;
	float GetMin() const;
	EProgressTitleType GetTitleType() const;
	float GetValue() const;
	bool GetWholeNumbers() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSlider">();
	}
	static class UGSlider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGSlider>();
	}
};
static_assert(alignof(UGSlider) == 0x000008, "Wrong alignment on UGSlider");
static_assert(sizeof(UGSlider) == 0x0004B8, "Wrong size on UGSlider");
static_assert(offsetof(UGSlider, bChangeOnClick) == 0x000448, "Member 'UGSlider::bChangeOnClick' has a wrong offset!");
static_assert(offsetof(UGSlider, bCanDrag) == 0x000449, "Member 'UGSlider::bCanDrag' has a wrong offset!");
static_assert(offsetof(UGSlider, OnChanged) == 0x000450, "Member 'UGSlider::OnChanged' has a wrong offset!");

// Class FairyGUI.GTextInput
// 0x0078 (0x03B8 - 0x0340)
class UGTextInput final : public UGObject
{
public:
	TMulticastInlineDelegate<void(class UEventContext* EventContext)> OnSubmit;                      // 0x0340(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_350[0x68];                                     // 0x0350(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyFormat();
	struct FNTextFormat GetTextFormat();
	void SetKeyboardType(int32 InKeyboardType);
	void SetMaxLength(int32 InMaxLength);
	void SetPassword(bool bInPassword);
	void SetPrompt(const class FString& InPrompt);
	void SetRestrict(const class FString& InRestrict);
	void SetSingleLine(bool InSingleLine);
	void SetTextFormat(const struct FNTextFormat& InTextFormat);

	bool IsSingleLine() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GTextInput">();
	}
	static class UGTextInput* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGTextInput>();
	}
};
static_assert(alignof(UGTextInput) == 0x000008, "Wrong alignment on UGTextInput");
static_assert(sizeof(UGTextInput) == 0x0003B8, "Wrong size on UGTextInput");
static_assert(offsetof(UGTextInput, OnSubmit) == 0x000340, "Member 'UGTextInput::OnSubmit' has a wrong offset!");

// Class FairyGUI.GTree
// 0x0038 (0x0538 - 0x0500)
class UGTree final : public UGList
{
public:
	int32                                         Indent;                                            // 0x0500(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ClickToExpand;                                     // 0x0504(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGTreeNode*                             RootNode;                                          // 0x0508(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_510[0x28];                                     // 0x0510(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CollapseAll(class UGTreeNode* Node);
	void ExpandAll(class UGTreeNode* Node);
	void OnCellTouchBegin(class UEventContext* Context);
	void SelectNode(class UGTreeNode* Node, bool bScrollItToView);
	void SetOnTreeNodeWillExpand(const TDelegate<void(class UGTreeNode* Node, bool bToExpand)>& InDelegate);
	void SetTreeNodeRenderer(const TDelegate<void(class UGTreeNode* Node, class UGComponent* Obj)>& InDelegate);
	void UnselectNode(class UGTreeNode* Node);

	class UGTreeNode* GetRootNode() const;
	class UGTreeNode* GetSelectedNode() const;
	void GetSelectedNodes(TArray<class UGTreeNode*>* Result) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GTree">();
	}
	static class UGTree* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGTree>();
	}
};
static_assert(alignof(UGTree) == 0x000008, "Wrong alignment on UGTree");
static_assert(sizeof(UGTree) == 0x000538, "Wrong size on UGTree");
static_assert(offsetof(UGTree, Indent) == 0x000500, "Member 'UGTree::Indent' has a wrong offset!");
static_assert(offsetof(UGTree, ClickToExpand) == 0x000504, "Member 'UGTree::ClickToExpand' has a wrong offset!");
static_assert(offsetof(UGTree, RootNode) == 0x000508, "Member 'UGTree::RootNode' has a wrong offset!");

// Class FairyGUI.GTreeNode
// 0x0058 (0x0080 - 0x0028)
class UGTreeNode final : public UObject
{
public:
	struct FNVariant                              UserData;                                          // 0x0028(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UGComponent*                            Cell;                                              // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UGTreeNode*>                     Children;                                          // 0x0058(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_68[0x18];                                      // 0x0068(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UGTreeNode* CreateNode(bool bIsFolder, const class FString& ResourceURL);

	class UGTreeNode* AddChild(class UGTreeNode* Child);
	class UGTreeNode* AddChildAt(class UGTreeNode* Child, int32 Index_0);
	void RemoveChild(class UGTreeNode* Child);
	void RemoveChildAt(int32 Index_0);
	void RemoveChildren(int32 BeginIndex, int32 EndIndex);
	void SetChildIndex(class UGTreeNode* Child, int32 Index_0);
	void SetExpaned(bool bInExpanded);
	void SetIcon(const class FString& InIcon);
	void SetParent(class UGTreeNode* InParent);
	void SetText(const class FString& InText);
	void SwapChildren(class UGTreeNode* Child, class UGTreeNode* Child2);
	void SwapChildrenAt(int32 Index1, int32 Index2);

	class UGComponent* GetCell() const;
	class UGTreeNode* GetChildAt(int32 Index_0) const;
	int32 GetChildIndex(const class UGTreeNode* Child) const;
	class FString GetIcon() const;
	class UGTreeNode* GetNextSibling() const;
	class UGTreeNode* GetParent() const;
	class UGTreeNode* GetPrevSibling() const;
	class FString GetText() const;
	class UGTree* GetTree() const;
	bool IsExpanded() const;
	bool IsFolder() const;
	int32 NumChildren() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GTreeNode">();
	}
	static class UGTreeNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGTreeNode>();
	}
};
static_assert(alignof(UGTreeNode) == 0x000008, "Wrong alignment on UGTreeNode");
static_assert(sizeof(UGTreeNode) == 0x000080, "Wrong size on UGTreeNode");
static_assert(offsetof(UGTreeNode, UserData) == 0x000028, "Member 'UGTreeNode::UserData' has a wrong offset!");
static_assert(offsetof(UGTreeNode, Cell) == 0x000050, "Member 'UGTreeNode::Cell' has a wrong offset!");
static_assert(offsetof(UGTreeNode, Children) == 0x000058, "Member 'UGTreeNode::Children' has a wrong offset!");

// Class FairyGUI.GWindow
// 0x00A8 (0x04F0 - 0x0448)
class UGWindow final : public UGComponent
{
public:
	bool                                          bBringToFontOnClick;                               // 0x0448(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_449[0x3];                                      // 0x0449(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(class UGWindow* Window)>       InitCallback;                                      // 0x044C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(class UGWindow* Window)>       ShownCallback;                                     // 0x045C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(class UGWindow* Window)>       HideCallback;                                      // 0x046C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(class UGWindow* Window)>       ShowingCallback;                                   // 0x047C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(class UGWindow* Window)>       HidingCallback;                                    // 0x048C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_49C[0x4];                                      // 0x049C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGComponent*                            ContentPane;                                       // 0x04A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGObject*                               ModalWaitPane;                                     // 0x04A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGComponent*                            FrameObject;                                       // 0x04B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGObject*                               CloseButton;                                       // 0x04B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGObject*                               DragArea;                                          // 0x04C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGObject*                               ContentArea;                                       // 0x04C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4D0[0x20];                                     // 0x04D0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UGWindow* CreateWidget(const class FString& PackageName, const class FString& ResourceName, class UObject* WorldContextObject);

	void BringToFront();
	void CloseEventHandler(class UEventContext* Context);
	bool CloseModalWait(int32 InRequestingCmd);
	void Hide();
	void HideImmediately();
	void OnDragStartHandler(class UEventContext* Context);
	void SetCloseButton(class UGObject* Obj);
	void SetContentArea(class UGObject* Obj);
	void SetContentPane(class UGComponent* Obj);
	void SetDragArea(class UGObject* Obj);
	void SetModal(bool bInModal);
	void Show();
	void ShowModalWait(int32 InRequestingCmd);
	void ToggleStatus();

	class UGObject* GetCloseButton() const;
	class UGObject* GetContentArea() const;
	class UGComponent* GetContentPane() const;
	class UGObject* GetDragArea() const;
	class UGComponent* GetFrame() const;
	class UGObject* GetModalWaitingPane() const;
	bool IsModal() const;
	bool IsShowing() const;
	bool IsTop() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GWindow">();
	}
	static class UGWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGWindow>();
	}
};
static_assert(alignof(UGWindow) == 0x000008, "Wrong alignment on UGWindow");
static_assert(sizeof(UGWindow) == 0x0004F0, "Wrong size on UGWindow");
static_assert(offsetof(UGWindow, bBringToFontOnClick) == 0x000448, "Member 'UGWindow::bBringToFontOnClick' has a wrong offset!");
static_assert(offsetof(UGWindow, InitCallback) == 0x00044C, "Member 'UGWindow::InitCallback' has a wrong offset!");
static_assert(offsetof(UGWindow, ShownCallback) == 0x00045C, "Member 'UGWindow::ShownCallback' has a wrong offset!");
static_assert(offsetof(UGWindow, HideCallback) == 0x00046C, "Member 'UGWindow::HideCallback' has a wrong offset!");
static_assert(offsetof(UGWindow, ShowingCallback) == 0x00047C, "Member 'UGWindow::ShowingCallback' has a wrong offset!");
static_assert(offsetof(UGWindow, HidingCallback) == 0x00048C, "Member 'UGWindow::HidingCallback' has a wrong offset!");
static_assert(offsetof(UGWindow, ContentPane) == 0x0004A0, "Member 'UGWindow::ContentPane' has a wrong offset!");
static_assert(offsetof(UGWindow, ModalWaitPane) == 0x0004A8, "Member 'UGWindow::ModalWaitPane' has a wrong offset!");
static_assert(offsetof(UGWindow, FrameObject) == 0x0004B0, "Member 'UGWindow::FrameObject' has a wrong offset!");
static_assert(offsetof(UGWindow, CloseButton) == 0x0004B8, "Member 'UGWindow::CloseButton' has a wrong offset!");
static_assert(offsetof(UGWindow, DragArea) == 0x0004C0, "Member 'UGWindow::DragArea' has a wrong offset!");
static_assert(offsetof(UGWindow, ContentArea) == 0x0004C8, "Member 'UGWindow::ContentArea' has a wrong offset!");

// Class FairyGUI.NTexture
// 0x0050 (0x0078 - 0x0028)
class UNTexture final : public UObject
{
public:
	class UNTexture*                              Root;                                              // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             NativeTexture;                                     // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x40];                                      // 0x0038(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NTexture">();
	}
	static class UNTexture* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNTexture>();
	}
};
static_assert(alignof(UNTexture) == 0x000008, "Wrong alignment on UNTexture");
static_assert(sizeof(UNTexture) == 0x000078, "Wrong size on UNTexture");
static_assert(offsetof(UNTexture, Root) == 0x000028, "Member 'UNTexture::Root' has a wrong offset!");
static_assert(offsetof(UNTexture, NativeTexture) == 0x000030, "Member 'UNTexture::NativeTexture' has a wrong offset!");

// Class FairyGUI.PopupMenu
// 0x0010 (0x0038 - 0x0028)
class UPopupMenu final : public UObject
{
public:
	class UGComponent*                            ContentPane;                                       // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UPopupMenu* CreatePopupMenu(const class FString& ResourceURL, class UObject* WorldContextObject);

	class UGButton* AddItem(const class FString& Caption, const TDelegate<void(class UEventContext* EventContext)>& Callback);
	class UGButton* AddItemAt(const class FString& Caption, int32 Index_0, const TDelegate<void(class UEventContext* EventContext)>& Callback);
	void AddSeperator();
	void ClearItems();
	bool RemoveItem(const class FString& Name_0);
	void SetItemCheckable(const class FString& Name_0, bool bCheckable);
	void SetItemChecked(const class FString& Name_0, bool bCheck);
	void SetItemGrayed(const class FString& Name_0, bool bGrayed);
	void SetItemText(const class FString& Name_0, const class FString& Caption);
	void SetItemVisible(const class FString& Name_0, bool bVisible);
	void Show(class UGObject* AtObject, EPopupDirection Dir);

	class UGComponent* GetContentPane() const;
	int32 GetItemCount() const;
	class FString GetItemName(int32 Index_0) const;
	class UGList* GetList() const;
	bool IsItemChecked(const class FString& Name_0) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PopupMenu">();
	}
	static class UPopupMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPopupMenu>();
	}
};
static_assert(alignof(UPopupMenu) == 0x000008, "Wrong alignment on UPopupMenu");
static_assert(sizeof(UPopupMenu) == 0x000038, "Wrong size on UPopupMenu");
static_assert(offsetof(UPopupMenu, ContentPane) == 0x000028, "Member 'UPopupMenu::ContentPane' has a wrong offset!");

// Class FairyGUI.ScrollPane
// 0x0128 (0x0150 - 0x0028)
class UScrollPane final : public UObject
{
public:
	uint8                                         bBouncebackEffect : 1;                             // 0x0028(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bTouchEffect : 1;                                  // 0x0028(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bInertiaDisabled : 1;                              // 0x0028(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bMouseWheelEnabled : 1;                            // 0x0028(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSnapToItem : 1;                                   // 0x0028(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPageMode : 1;                                     // 0x0028(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DecelerationRate;                                  // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScrollStep;                                        // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGController*                           PageController;                                    // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x28];                                      // 0x0040(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UGScrollBar*                            HzScrollBar;                                       // 0x0068(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGScrollBar*                            VtScrollBar;                                       // 0x0070(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGComponent*                            Header;                                            // 0x0078(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGComponent*                            Footer;                                            // 0x0080(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_88[0xC8];                                      // 0x0088(0x00C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CancelDragging();
	void LockFooter(int32 Size);
	void LockHeader(int32 Size);
	void ScrollBottom(bool bAnimation);
	void ScrollDown(float Ratio, bool bAnimation);
	void ScrollLeft(float Ratio, bool bAnimation);
	void ScrollRight(float Ratio, bool bAnimation);
	void ScrollTop(bool bAnimation);
	void ScrollToView(class UGObject* Obj, bool bAnimation, bool bSetFirst);
	void ScrollUp(float Ratio, bool bAnimation);
	void SetPageX(int32 PageX, bool bAnimation);
	void SetPageY(int32 PageY, bool bAnimation);
	void SetPercX(float Value, bool bAnimation);
	void SetPercY(float Value, bool bAnimation);
	void SetPosX(float Value, bool bAnimation);
	void SetPosY(float Value, bool bAnimation);

	const struct FVector2D GetContentSize() const;
	class UGComponent* GetFooter() const;
	class UGComponent* GetHeader() const;
	class UGScrollBar* GetHzScrollBar() const;
	int32 GetPageX() const;
	int32 GetPageY() const;
	float GetPercX() const;
	float GetPercY() const;
	float GetPosX() const;
	float GetPosY() const;
	float GetScrollingPosX() const;
	float GetScrollingPosY() const;
	const struct FVector2D GetViewSize() const;
	class UGScrollBar* GetVtScrollBar() const;
	bool IsBottomMost() const;
	bool IsChildInView(class UGObject* Obj) const;
	bool IsRightMost() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScrollPane">();
	}
	static class UScrollPane* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScrollPane>();
	}
};
static_assert(alignof(UScrollPane) == 0x000008, "Wrong alignment on UScrollPane");
static_assert(sizeof(UScrollPane) == 0x000150, "Wrong size on UScrollPane");
static_assert(offsetof(UScrollPane, DecelerationRate) == 0x00002C, "Member 'UScrollPane::DecelerationRate' has a wrong offset!");
static_assert(offsetof(UScrollPane, ScrollStep) == 0x000030, "Member 'UScrollPane::ScrollStep' has a wrong offset!");
static_assert(offsetof(UScrollPane, PageController) == 0x000038, "Member 'UScrollPane::PageController' has a wrong offset!");
static_assert(offsetof(UScrollPane, HzScrollBar) == 0x000068, "Member 'UScrollPane::HzScrollBar' has a wrong offset!");
static_assert(offsetof(UScrollPane, VtScrollBar) == 0x000070, "Member 'UScrollPane::VtScrollBar' has a wrong offset!");
static_assert(offsetof(UScrollPane, Header) == 0x000078, "Member 'UScrollPane::Header' has a wrong offset!");
static_assert(offsetof(UScrollPane, Footer) == 0x000080, "Member 'UScrollPane::Footer' has a wrong offset!");

// Class FairyGUI.Transition
// 0x0080 (0x00A8 - 0x0028)
class UTransition final : public UObject
{
public:
	class FString                                 Name_0;                                            // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x70];                                      // 0x0038(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangePlayTimes(int32 InTimes);
	void ClearHooks();
	void Play(const TDelegate<void()>& InCompleteCallback, int32 InTimes, float InDelay, float InStartTime, float InEndTime);
	void PlayReverse(const TDelegate<void()>& InCompleteCallback, int32 InTimes, float InDelay);
	void SetAutoPlay(bool bInAutoPlay, int32 InTimes, float InDelay);
	void SetDuration(const class FString& InLabel, float InDuration);
	void SetHook(const class FString& InLabel, TDelegate<void()> Callback);
	void SetPaused(bool bInPaused);
	void SetTarget(const class FString& InLabel, class UGObject* InTarget);
	void SetTimeScale(float InTimeScale);
	void SetValue(const class FString& InLabel, const TArray<struct FNVariant>& InValues);
	void Stop(bool bSetToComplete, bool bProcessCallback);

	float GetLabelTime(const class FString& InLabel) const;
	float GetTimeScale() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Transition">();
	}
	static class UTransition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTransition>();
	}
};
static_assert(alignof(UTransition) == 0x000008, "Wrong alignment on UTransition");
static_assert(sizeof(UTransition) == 0x0000A8, "Wrong size on UTransition");
static_assert(offsetof(UTransition, Name_0) == 0x000028, "Member 'UTransition::Name_0' has a wrong offset!");

// Class FairyGUI.UIPackage
// 0x01C0 (0x01E8 - 0x0028)
class UUIPackage final : public UObject
{
public:
	uint8                                         Pad_28[0x30];                                      // 0x0028(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UUIPackageAsset*                        Asset;                                             // 0x0058(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_60[0x188];                                     // 0x0060(0x0188)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UUIPackage* AddPackage(class UUIPackageAsset* InAsset, class UObject* WorldContextObject);
	static class UGObject* CreateObject(const class FString& PackageName, const class FString& ResourceName, class UObject* WorldContextObject, TSubclassOf<class UGObject> ClassType);
	static class UGObject* CreateObjectFromURL(const class FString& URL, class UObject* WorldContextObject, TSubclassOf<class UGObject> ClassType);
	static class FString GetBranch();
	static class UUIPackage* GetPackageByID(const class FString& PackageID);
	static class UUIPackage* GetPackageByName(const class FString& PackageName);
	static class FString GetVar(const class FString& VarKey);
	static void RegisterFont(const class FString& FontFace, class UObject* Font);
	static void RemoveAllPackages();
	static void RemovePackage(const class FString& IDOrName, class UObject* WorldContextObject);
	static void SetBranch(const class FString& InBranch);
	static void SetVar(const class FString& VarKey, const class FString& VarValue);

	class FString GetID() const;
	class FString GetName() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPackage">();
	}
	static class UUIPackage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPackage>();
	}
};
static_assert(alignof(UUIPackage) == 0x000008, "Wrong alignment on UUIPackage");
static_assert(sizeof(UUIPackage) == 0x0001E8, "Wrong size on UUIPackage");
static_assert(offsetof(UUIPackage, Asset) == 0x000058, "Member 'UUIPackage::Asset' has a wrong offset!");

// Class FairyGUI.UIPackageStatic
// 0x0160 (0x0188 - 0x0028)
class UUIPackageStatic final : public UObject
{
public:
	TArray<class UUIPackage*>                     PackageList;                                       // 0x0028(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x100];                                     // 0x0038(0x0100)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, class UObject*>           Fonts;                                             // 0x0138(0x0050)(Transient, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPackageStatic">();
	}
	static class UUIPackageStatic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPackageStatic>();
	}
};
static_assert(alignof(UUIPackageStatic) == 0x000008, "Wrong alignment on UUIPackageStatic");
static_assert(sizeof(UUIPackageStatic) == 0x000188, "Wrong size on UUIPackageStatic");
static_assert(offsetof(UUIPackageStatic, PackageList) == 0x000028, "Member 'UUIPackageStatic::PackageList' has a wrong offset!");
static_assert(offsetof(UUIPackageStatic, Fonts) == 0x000138, "Member 'UUIPackageStatic::Fonts' has a wrong offset!");

// Class FairyGUI.UIPackageAsset
// 0x0010 (0x0038 - 0x0028)
class UUIPackageAsset final : public UObject
{
public:
	TArray<uint8>                                 Data;                                              // 0x0028(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIPackageAsset">();
	}
	static class UUIPackageAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIPackageAsset>();
	}
};
static_assert(alignof(UUIPackageAsset) == 0x000008, "Wrong alignment on UUIPackageAsset");
static_assert(sizeof(UUIPackageAsset) == 0x000038, "Wrong size on UUIPackageAsset");
static_assert(offsetof(UUIPackageAsset, Data) == 0x000028, "Member 'UUIPackageAsset::Data' has a wrong offset!");

}

