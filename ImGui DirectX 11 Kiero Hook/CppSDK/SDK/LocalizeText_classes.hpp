#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: LocalizeText

#include "Basic.hpp"

#include "SlateCore_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "LocalizeText_structs.hpp"
#include "UMG_classes.hpp"


namespace SDK
{

// Class LocalizeText.LocalizeText
// 0x07A8 (0x0910 - 0x0168)
class ULocalizeText final : public UTextLayoutWidget
{
public:
	bool                                          NotLocalize;                                       // 0x0168(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CapitalOnly;                                       // 0x0169(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16A[0x6];                                      // 0x016A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LocalizeKey;                                       // 0x0170(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Text;                                              // 0x0180(0x0018)(Edit, NativeAccessSpecifierPublic)
	TDelegate<void()>                             TextDelegate;                                      // 0x0198(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	struct FSlateColor                            ColorAndOpacity;                                   // 0x01A8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TDelegate<void()>                             ColorAndOpacityDelegate;                           // 0x01D0(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	struct FSlateFontInfo                         Font;                                              // 0x01E0(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_248[0x8];                                      // 0x0248(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            StrikeBrush;                                       // 0x0250(0x0110)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FVector2D                              ShadowOffset;                                      // 0x0360(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ShadowColorAndOpacity;                             // 0x0368(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             ShadowColorAndOpacityDelegate;                     // 0x0378(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MinDesiredWidth;                                   // 0x0388(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWrapWithInvalidationPanel;                        // 0x038C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38D[0x3];                                      // 0x038D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LetterSpacing;                                     // 0x0390(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_394[0x4];                                      // 0x0394(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ULocalizeTransferAgent*                 Agent;                                             // 0x0398(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTextBlockStyle                        WidgetStyle;                                       // 0x03A0(0x0540)(Edit, BlueprintVisible, AdvancedDisplay, NativeAccessSpecifierPublic)
	bool                                          bSimpleTextMode;                                   // 0x08E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8E1[0x27];                                     // 0x08E1(0x0027)(Fixing Size After Last Property [ Dumper-7 ])
	ETextScaleRule                                ScaleRule;                                         // 0x0908(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETextVerticalAlign                            VerticalAlign;                                     // 0x0909(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_90A[0x6];                                      // 0x090A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UMaterialInstanceDynamic* GetDynamicFontMaterial();
	class UMaterialInstanceDynamic* GetDynamicOutlineMaterial();
	void Refresh();
	void RefreshText();
	void SetAutoWrapText(bool InAutoTextWrap);
	void SetCapitalOnly(bool bCapitalOnly);
	void SetColorAndOpacity(const struct FSlateColor& InColorAndOpacity);
	void SetFont(const struct FSlateFontInfo& InFontInfo);
	void SetMinDesiredWidth(float InMinDesiredWidth);
	void SetOpacity(float InOpacity);
	void SetScaleRule(ETextScaleRule InScaleRule);
	void SetShadowColorAndOpacity(const struct FLinearColor& InShadowColorAndOpacity);
	void SetShadowOffset(const struct FVector2D& InShadowOffset);
	void SetStrikeBrush(const struct FSlateBrush& InStrikeBrush);
	void SetText(const class FText& InText);
	void SetVerticalAlign(ETextVerticalAlign InScaleAlign);
	void SetWrapTextAt(float InWrapTextAt);

	class FString GetLocalizeKey() const;
	class FText GetText() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocalizeText">();
	}
	static class ULocalizeText* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULocalizeText>();
	}
};
static_assert(alignof(ULocalizeText) == 0x000010, "Wrong alignment on ULocalizeText");
static_assert(sizeof(ULocalizeText) == 0x000910, "Wrong size on ULocalizeText");
static_assert(offsetof(ULocalizeText, NotLocalize) == 0x000168, "Member 'ULocalizeText::NotLocalize' has a wrong offset!");
static_assert(offsetof(ULocalizeText, CapitalOnly) == 0x000169, "Member 'ULocalizeText::CapitalOnly' has a wrong offset!");
static_assert(offsetof(ULocalizeText, LocalizeKey) == 0x000170, "Member 'ULocalizeText::LocalizeKey' has a wrong offset!");
static_assert(offsetof(ULocalizeText, Text) == 0x000180, "Member 'ULocalizeText::Text' has a wrong offset!");
static_assert(offsetof(ULocalizeText, TextDelegate) == 0x000198, "Member 'ULocalizeText::TextDelegate' has a wrong offset!");
static_assert(offsetof(ULocalizeText, ColorAndOpacity) == 0x0001A8, "Member 'ULocalizeText::ColorAndOpacity' has a wrong offset!");
static_assert(offsetof(ULocalizeText, ColorAndOpacityDelegate) == 0x0001D0, "Member 'ULocalizeText::ColorAndOpacityDelegate' has a wrong offset!");
static_assert(offsetof(ULocalizeText, Font) == 0x0001E0, "Member 'ULocalizeText::Font' has a wrong offset!");
static_assert(offsetof(ULocalizeText, StrikeBrush) == 0x000250, "Member 'ULocalizeText::StrikeBrush' has a wrong offset!");
static_assert(offsetof(ULocalizeText, ShadowOffset) == 0x000360, "Member 'ULocalizeText::ShadowOffset' has a wrong offset!");
static_assert(offsetof(ULocalizeText, ShadowColorAndOpacity) == 0x000368, "Member 'ULocalizeText::ShadowColorAndOpacity' has a wrong offset!");
static_assert(offsetof(ULocalizeText, ShadowColorAndOpacityDelegate) == 0x000378, "Member 'ULocalizeText::ShadowColorAndOpacityDelegate' has a wrong offset!");
static_assert(offsetof(ULocalizeText, MinDesiredWidth) == 0x000388, "Member 'ULocalizeText::MinDesiredWidth' has a wrong offset!");
static_assert(offsetof(ULocalizeText, bWrapWithInvalidationPanel) == 0x00038C, "Member 'ULocalizeText::bWrapWithInvalidationPanel' has a wrong offset!");
static_assert(offsetof(ULocalizeText, LetterSpacing) == 0x000390, "Member 'ULocalizeText::LetterSpacing' has a wrong offset!");
static_assert(offsetof(ULocalizeText, Agent) == 0x000398, "Member 'ULocalizeText::Agent' has a wrong offset!");
static_assert(offsetof(ULocalizeText, WidgetStyle) == 0x0003A0, "Member 'ULocalizeText::WidgetStyle' has a wrong offset!");
static_assert(offsetof(ULocalizeText, bSimpleTextMode) == 0x0008E0, "Member 'ULocalizeText::bSimpleTextMode' has a wrong offset!");
static_assert(offsetof(ULocalizeText, ScaleRule) == 0x000908, "Member 'ULocalizeText::ScaleRule' has a wrong offset!");
static_assert(offsetof(ULocalizeText, VerticalAlign) == 0x000909, "Member 'ULocalizeText::VerticalAlign' has a wrong offset!");

// Class LocalizeText.LocalizeTransferAgent
// 0x0000 (0x0028 - 0x0028)
class ULocalizeTransferAgent final : public UObject
{
public:
	class FString GetLocalizeText(const class FString& Language, const class FString& Key);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocalizeTransferAgent">();
	}
	static class ULocalizeTransferAgent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULocalizeTransferAgent>();
	}
};
static_assert(alignof(ULocalizeTransferAgent) == 0x000008, "Wrong alignment on ULocalizeTransferAgent");
static_assert(sizeof(ULocalizeTransferAgent) == 0x000028, "Wrong size on ULocalizeTransferAgent");

}

