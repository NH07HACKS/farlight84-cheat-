#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: TcpSocketPlugin

#include "Basic.hpp"

#include "TcpSocketPlugin_classes.hpp"
#include "TcpSocketPlugin_parameters.hpp"


namespace SDK
{

// Function TcpSocketPlugin.TcpSocketConnection.Concat_BytesBytes
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<uint8>&                    A                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<uint8>&                    B                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<uint8>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<uint8> ATcpSocketConnection::Concat_BytesBytes(const TArray<uint8>& A, const TArray<uint8>& B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TcpSocketConnection", "Concat_BytesBytes");

	Params::TcpSocketConnection_Concat_BytesBytes Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TcpSocketPlugin.TcpSocketConnection.Conv_ByteToBytes
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// uint8                                   InByte                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<uint8>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<uint8> ATcpSocketConnection::Conv_ByteToBytes(uint8 InByte)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TcpSocketConnection", "Conv_ByteToBytes");

	Params::TcpSocketConnection_Conv_ByteToBytes Parms{};

	Parms.InByte = InByte;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TcpSocketPlugin.TcpSocketConnection.Conv_FloatToBytes
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   InFloat                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<uint8>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<uint8> ATcpSocketConnection::Conv_FloatToBytes(float InFloat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TcpSocketConnection", "Conv_FloatToBytes");

	Params::TcpSocketConnection_Conv_FloatToBytes Parms{};

	Parms.InFloat = InFloat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TcpSocketPlugin.TcpSocketConnection.Conv_IntToBytes
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   inInt                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<uint8>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<uint8> ATcpSocketConnection::Conv_IntToBytes(int32 inInt)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TcpSocketConnection", "Conv_IntToBytes");

	Params::TcpSocketConnection_Conv_IntToBytes Parms{};

	Parms.inInt = inInt;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TcpSocketPlugin.TcpSocketConnection.Conv_StringToBytes
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FString&                    InStr                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<uint8>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TArray<uint8> ATcpSocketConnection::Conv_StringToBytes(const class FString& InStr)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TcpSocketConnection", "Conv_StringToBytes");

	Params::TcpSocketConnection_Conv_StringToBytes Parms{};

	Parms.InStr = std::move(InStr);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TcpSocketPlugin.TcpSocketConnection.Message_ReadByte
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<uint8>&                          Message                                                (Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 ATcpSocketConnection::Message_ReadByte(TArray<uint8>& Message)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TcpSocketConnection", "Message_ReadByte");

	Params::TcpSocketConnection_Message_ReadByte Parms{};

	Parms.Message = std::move(Message);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Message = std::move(Parms.Message);

	return Parms.ReturnValue;
}


// Function TcpSocketPlugin.TcpSocketConnection.Message_ReadBytes
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   NumBytes                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<uint8>&                          Message                                                (Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<uint8>*                          ReturnArray                                            (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATcpSocketConnection::Message_ReadBytes(int32 NumBytes, TArray<uint8>& Message, TArray<uint8>* ReturnArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TcpSocketConnection", "Message_ReadBytes");

	Params::TcpSocketConnection_Message_ReadBytes Parms{};

	Parms.NumBytes = NumBytes;
	Parms.Message = std::move(Message);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Message = std::move(Parms.Message);

	if (ReturnArray != nullptr)
		*ReturnArray = std::move(Parms.ReturnArray);

	return Parms.ReturnValue;
}


// Function TcpSocketPlugin.TcpSocketConnection.Message_ReadFloat
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<uint8>&                          Message                                                (Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATcpSocketConnection::Message_ReadFloat(TArray<uint8>& Message)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TcpSocketConnection", "Message_ReadFloat");

	Params::TcpSocketConnection_Message_ReadFloat Parms{};

	Parms.Message = std::move(Message);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Message = std::move(Parms.Message);

	return Parms.ReturnValue;
}


// Function TcpSocketPlugin.TcpSocketConnection.Message_ReadInt
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<uint8>&                          Message                                                (Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ATcpSocketConnection::Message_ReadInt(TArray<uint8>& Message)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TcpSocketConnection", "Message_ReadInt");

	Params::TcpSocketConnection_Message_ReadInt Parms{};

	Parms.Message = std::move(Message);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Message = std::move(Parms.Message);

	return Parms.ReturnValue;
}


// Function TcpSocketPlugin.TcpSocketConnection.Message_ReadString
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<uint8>&                          Message                                                (Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   StringLength                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ATcpSocketConnection::Message_ReadString(TArray<uint8>& Message, int32 StringLength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TcpSocketConnection", "Message_ReadString");

	Params::TcpSocketConnection_Message_ReadString Parms{};

	Parms.Message = std::move(Message);
	Parms.StringLength = StringLength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Message = std::move(Parms.Message);

	return Parms.ReturnValue;
}


// Function TcpSocketPlugin.TcpSocketConnection.Connect
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FString&                    ipAddress                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Port                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TDelegate<void(int32 ConnectionId)>&OnDisconnected                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const TDelegate<void(int32 ConnectionId)>&OnConnected                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const TDelegate<void(int32 ConnectionId, TArray<uint8>& Message)>&OnMessageReceived                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// int32*                                  ConnectionId                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATcpSocketConnection::Connect(const class FString& ipAddress, int32 Port, const TDelegate<void(int32 ConnectionId)>& OnDisconnected, const TDelegate<void(int32 ConnectionId)>& OnConnected, const TDelegate<void(int32 ConnectionId, TArray<uint8>& Message)>& OnMessageReceived, int32* ConnectionId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TcpSocketConnection", "Connect");

	Params::TcpSocketConnection_Connect Parms{};

	Parms.ipAddress = std::move(ipAddress);
	Parms.Port = Port;
	Parms.OnDisconnected = OnDisconnected;
	Parms.OnConnected = OnConnected;
	Parms.OnMessageReceived = OnMessageReceived;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ConnectionId != nullptr)
		*ConnectionId = Parms.ConnectionId;
}


// Function TcpSocketPlugin.TcpSocketConnection.Disconnect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ConnectionId                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATcpSocketConnection::Disconnect(int32 ConnectionId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TcpSocketConnection", "Disconnect");

	Params::TcpSocketConnection_Disconnect Parms{};

	Parms.ConnectionId = ConnectionId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TcpSocketPlugin.TcpSocketConnection.isConnected
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ConnectionId                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATcpSocketConnection::isConnected(int32 ConnectionId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TcpSocketConnection", "isConnected");

	Params::TcpSocketConnection_isConnected Parms{};

	Parms.ConnectionId = ConnectionId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TcpSocketPlugin.TcpSocketConnection.SendData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ConnectionId                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<uint8>&                    DataToSend                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATcpSocketConnection::SendData(int32 ConnectionId, const TArray<uint8>& DataToSend)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TcpSocketConnection", "SendData");

	Params::TcpSocketConnection_SendData Parms{};

	Parms.ConnectionId = ConnectionId;
	Parms.DataToSend = std::move(DataToSend);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}

}

