#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: DynamicRepresentation

#include "Basic.hpp"

#include "Engine_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "DynamicRepresentation_structs.hpp"
#include "AnimationBudgetAllocator_classes.hpp"


namespace SDK
{

// Class DynamicRepresentation.DynamicRepresentationInterface
// 0x0000 (0x0000 - 0x0000)
class IDynamicRepresentationInterface final
{
public:
	void BeginRelevance(const struct FActorId& ActorId, const class UDynamicRepresentationDefinition* InDefinition, ESpatialLODLevel LOD, class UObject* InCustomData);
	void EndRelevance(const struct FActorId& ActorId, const class UDynamicRepresentationDefinition* InDefinition, class UObject* InCustomData);
	void LodChanged(const struct FActorId& ActorId, const class UDynamicRepresentationDefinition* InDefinition, ESpatialLODLevel OldLOD, ESpatialLODLevel NewLOD, class UObject* InCustomData);
	void PlayRepresentationAnimation(const struct FActorId& ActorId, const class FName& Animation);
	void StopRepresentationAnimation(const struct FActorId& ActorId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicRepresentationInterface">();
	}
	static class IDynamicRepresentationInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDynamicRepresentationInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IDynamicRepresentationInterface) == 0x000001, "Wrong alignment on IDynamicRepresentationInterface");
static_assert(sizeof(IDynamicRepresentationInterface) == 0x000001, "Wrong size on IDynamicRepresentationInterface");

// Class DynamicRepresentation.DynamicInstanceVisualizationStaticMeshComponent
// 0x0000 (0x0880 - 0x0880)
class UDynamicInstanceVisualizationStaticMeshComponent final : public UStaticMeshComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicInstanceVisualizationStaticMeshComponent">();
	}
	static class UDynamicInstanceVisualizationStaticMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicInstanceVisualizationStaticMeshComponent>();
	}
};
static_assert(alignof(UDynamicInstanceVisualizationStaticMeshComponent) == 0x000010, "Wrong alignment on UDynamicInstanceVisualizationStaticMeshComponent");
static_assert(sizeof(UDynamicInstanceVisualizationStaticMeshComponent) == 0x000880, "Wrong size on UDynamicInstanceVisualizationStaticMeshComponent");

// Class DynamicRepresentation.DynamicInstanceVisualizationActor
// 0x0020 (0x02F8 - 0x02D8)
class ADynamicInstanceVisualizationActor final : public AActor
{
public:
	uint8                                         Pad_2D8[0x8];                                      // 0x02D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UDynamicRepresentationDefinition*       Definition;                                        // 0x02E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UObject*                                CustomData;                                        // 0x02E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x02F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicInstanceVisualizationActor">();
	}
	static class ADynamicInstanceVisualizationActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADynamicInstanceVisualizationActor>();
	}
};
static_assert(alignof(ADynamicInstanceVisualizationActor) == 0x000008, "Wrong alignment on ADynamicInstanceVisualizationActor");
static_assert(sizeof(ADynamicInstanceVisualizationActor) == 0x0002F8, "Wrong size on ADynamicInstanceVisualizationActor");
static_assert(offsetof(ADynamicInstanceVisualizationActor, Definition) == 0x0002E0, "Member 'ADynamicInstanceVisualizationActor::Definition' has a wrong offset!");
static_assert(offsetof(ADynamicInstanceVisualizationActor, CustomData) == 0x0002E8, "Member 'ADynamicInstanceVisualizationActor::CustomData' has a wrong offset!");
static_assert(offsetof(ADynamicInstanceVisualizationActor, StaticMeshComponent) == 0x0002F0, "Member 'ADynamicInstanceVisualizationActor::StaticMeshComponent' has a wrong offset!");

// Class DynamicRepresentation.DynamicInstanceVisualizationComponent
// 0x0020 (0x05F0 - 0x05D0)
class UDynamicInstanceVisualizationComponent final : public UPrimitiveComponent
{
public:
	class UStaticMesh*                            StaticMesh;                                        // 0x05D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FTransform>                     InstanceTransforms;                                // 0x05D8(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5E8[0x8];                                      // 0x05E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicInstanceVisualizationComponent">();
	}
	static class UDynamicInstanceVisualizationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicInstanceVisualizationComponent>();
	}
};
static_assert(alignof(UDynamicInstanceVisualizationComponent) == 0x000010, "Wrong alignment on UDynamicInstanceVisualizationComponent");
static_assert(sizeof(UDynamicInstanceVisualizationComponent) == 0x0005F0, "Wrong size on UDynamicInstanceVisualizationComponent");
static_assert(offsetof(UDynamicInstanceVisualizationComponent, StaticMesh) == 0x0005D0, "Member 'UDynamicInstanceVisualizationComponent::StaticMesh' has a wrong offset!");
static_assert(offsetof(UDynamicInstanceVisualizationComponent, InstanceTransforms) == 0x0005D8, "Member 'UDynamicInstanceVisualizationComponent::InstanceTransforms' has a wrong offset!");

// Class DynamicRepresentation.PoolBase
// 0x0060 (0x0088 - 0x0028)
class UPoolBase final : public UObject
{
public:
	TArray<class AActor*>                         AvailableActors;                                   // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSet<class AActor*>                           InUseActors;                                       // 0x0038(0x0050)(NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PoolBase">();
	}
	static class UPoolBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPoolBase>();
	}
};
static_assert(alignof(UPoolBase) == 0x000008, "Wrong alignment on UPoolBase");
static_assert(sizeof(UPoolBase) == 0x000088, "Wrong size on UPoolBase");
static_assert(offsetof(UPoolBase, AvailableActors) == 0x000028, "Member 'UPoolBase::AvailableActors' has a wrong offset!");
static_assert(offsetof(UPoolBase, InUseActors) == 0x000038, "Member 'UPoolBase::InUseActors' has a wrong offset!");

// Class DynamicRepresentation.DynamicRepresentationActorPoolSubsystem
// 0x0050 (0x0080 - 0x0030)
class UDynamicRepresentationActorPoolSubsystem final : public UWorldSubsystem
{
public:
	TMap<TSubclassOf<class AActor>, class UPoolBase*> ActorPools;                                    // 0x0030(0x0050)(NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicRepresentationActorPoolSubsystem">();
	}
	static class UDynamicRepresentationActorPoolSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicRepresentationActorPoolSubsystem>();
	}
};
static_assert(alignof(UDynamicRepresentationActorPoolSubsystem) == 0x000008, "Wrong alignment on UDynamicRepresentationActorPoolSubsystem");
static_assert(sizeof(UDynamicRepresentationActorPoolSubsystem) == 0x000080, "Wrong size on UDynamicRepresentationActorPoolSubsystem");
static_assert(offsetof(UDynamicRepresentationActorPoolSubsystem, ActorPools) == 0x000030, "Member 'UDynamicRepresentationActorPoolSubsystem::ActorPools' has a wrong offset!");

// Class DynamicRepresentation.DynamicRepresentationDefinition
// 0x0028 (0x0058 - 0x0030)
class UDynamicRepresentationDefinition final : public UPrimaryDataAsset
{
public:
	class FName                                   Grid;                                              // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     Actor;                                             // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UStaticMesh*>                    StaticMeshes;                                      // 0x0040(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOnlyManager;                                     // 0x0050(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicRepresentationDefinition">();
	}
	static class UDynamicRepresentationDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicRepresentationDefinition>();
	}
};
static_assert(alignof(UDynamicRepresentationDefinition) == 0x000008, "Wrong alignment on UDynamicRepresentationDefinition");
static_assert(sizeof(UDynamicRepresentationDefinition) == 0x000058, "Wrong size on UDynamicRepresentationDefinition");
static_assert(offsetof(UDynamicRepresentationDefinition, Grid) == 0x000030, "Member 'UDynamicRepresentationDefinition::Grid' has a wrong offset!");
static_assert(offsetof(UDynamicRepresentationDefinition, Actor) == 0x000038, "Member 'UDynamicRepresentationDefinition::Actor' has a wrong offset!");
static_assert(offsetof(UDynamicRepresentationDefinition, StaticMeshes) == 0x000040, "Member 'UDynamicRepresentationDefinition::StaticMeshes' has a wrong offset!");
static_assert(offsetof(UDynamicRepresentationDefinition, IsOnlyManager) == 0x000050, "Member 'UDynamicRepresentationDefinition::IsOnlyManager' has a wrong offset!");

// Class DynamicRepresentation.DynamicRepresentationFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UDynamicRepresentationFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool DynamicRepresentationSpawnActor(class UObject* WorldContextObject, const class UDynamicRepresentationDefinition* Definition, const struct FTransform& Transform);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicRepresentationFunctionLibrary">();
	}
	static class UDynamicRepresentationFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicRepresentationFunctionLibrary>();
	}
};
static_assert(alignof(UDynamicRepresentationFunctionLibrary) == 0x000008, "Wrong alignment on UDynamicRepresentationFunctionLibrary");
static_assert(sizeof(UDynamicRepresentationFunctionLibrary) == 0x000028, "Wrong size on UDynamicRepresentationFunctionLibrary");

// Class DynamicRepresentation.DynamicRepresentationAnimationState
// 0x0000 (0x0000 - 0x0000)
class IDynamicRepresentationAnimationState final
{
public:
	int32 GetState(const struct FActorId& ActorId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicRepresentationAnimationState">();
	}
	static class IDynamicRepresentationAnimationState* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDynamicRepresentationAnimationState>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IDynamicRepresentationAnimationState) == 0x000001, "Wrong alignment on IDynamicRepresentationAnimationState");
static_assert(sizeof(IDynamicRepresentationAnimationState) == 0x000001, "Wrong size on IDynamicRepresentationAnimationState");

// Class DynamicRepresentation.DynamicRepresentationSkeletalMeshComponentUtility
// 0x0000 (0x0D60 - 0x0D60)
class UDynamicRepresentationSkeletalMeshComponentUtility final : public USkeletalMeshComponentBudgeted
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicRepresentationSkeletalMeshComponentUtility">();
	}
	static class UDynamicRepresentationSkeletalMeshComponentUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicRepresentationSkeletalMeshComponentUtility>();
	}
};
static_assert(alignof(UDynamicRepresentationSkeletalMeshComponentUtility) == 0x000010, "Wrong alignment on UDynamicRepresentationSkeletalMeshComponentUtility");
static_assert(sizeof(UDynamicRepresentationSkeletalMeshComponentUtility) == 0x000D60, "Wrong size on UDynamicRepresentationSkeletalMeshComponentUtility");

// Class DynamicRepresentation.DynamicRepresentationComponent
// 0x0000 (0x0340 - 0x0340)
#pragma pack(push, 0x1)
class alignas(0x10) UDynamicRepresentationComponent : public USceneComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicRepresentationComponent">();
	}
	static class UDynamicRepresentationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicRepresentationComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UDynamicRepresentationComponent) == 0x000010, "Wrong alignment on UDynamicRepresentationComponent");
static_assert(sizeof(UDynamicRepresentationComponent) == 0x000340, "Wrong size on UDynamicRepresentationComponent");

// Class DynamicRepresentation.DynamicRepresentationSceneComponent
// 0x0020 (0x0360 - 0x0340)
class UDynamicRepresentationSceneComponent final : public UDynamicRepresentationComponent
{
public:
	class UDynamicRepresentationDefinition*       Definition;                                        // 0x0338(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          UseActorLocation;                                  // 0x0340(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_341[0x1F];                                     // 0x0341(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class AActor* GetVisualizationActor();
	void PlayAnimation(const class FName& Animation);
	void StopAnimation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicRepresentationSceneComponent">();
	}
	static class UDynamicRepresentationSceneComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicRepresentationSceneComponent>();
	}
};
static_assert(alignof(UDynamicRepresentationSceneComponent) == 0x000010, "Wrong alignment on UDynamicRepresentationSceneComponent");
static_assert(sizeof(UDynamicRepresentationSceneComponent) == 0x000360, "Wrong size on UDynamicRepresentationSceneComponent");
static_assert(offsetof(UDynamicRepresentationSceneComponent, Definition) == 0x000338, "Member 'UDynamicRepresentationSceneComponent::Definition' has a wrong offset!");
static_assert(offsetof(UDynamicRepresentationSceneComponent, UseActorLocation) == 0x000340, "Member 'UDynamicRepresentationSceneComponent::UseActorLocation' has a wrong offset!");

// Class DynamicRepresentation.DynamicRepresentationSettings
// 0x0018 (0x0050 - 0x0038)
class UDynamicRepresentationSettings final : public UDeveloperSettings
{
public:
	TArray<struct FSpatialHashGridDesc>           Grids;                                             // 0x0038(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxSpawnPerTick;                                   // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxDespawnPerTick;                                 // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicRepresentationSettings">();
	}
	static class UDynamicRepresentationSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicRepresentationSettings>();
	}
};
static_assert(alignof(UDynamicRepresentationSettings) == 0x000008, "Wrong alignment on UDynamicRepresentationSettings");
static_assert(sizeof(UDynamicRepresentationSettings) == 0x000050, "Wrong size on UDynamicRepresentationSettings");
static_assert(offsetof(UDynamicRepresentationSettings, Grids) == 0x000038, "Member 'UDynamicRepresentationSettings::Grids' has a wrong offset!");
static_assert(offsetof(UDynamicRepresentationSettings, MaxSpawnPerTick) == 0x000048, "Member 'UDynamicRepresentationSettings::MaxSpawnPerTick' has a wrong offset!");
static_assert(offsetof(UDynamicRepresentationSettings, MaxDespawnPerTick) == 0x00004C, "Member 'UDynamicRepresentationSettings::MaxDespawnPerTick' has a wrong offset!");

// Class DynamicRepresentation.DynamicRepresentationSubsystem
// 0x01B8 (0x0200 - 0x0048)
class alignas(0x10) UDynamicRepresentationSubsystem final : public UTickableWorldSubsystem
{
public:
	uint8                                         Pad_48[0x130];                                     // 0x0048(0x0130)(Fixing Size After Last Property [ Dumper-7 ])
	class AVisualizationSceneHelperActor*         VisualizationSceneHelperActor;                     // 0x0178(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_180[0x80];                                     // 0x0180(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicRepresentationSubsystem">();
	}
	static class UDynamicRepresentationSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicRepresentationSubsystem>();
	}
};
static_assert(alignof(UDynamicRepresentationSubsystem) == 0x000010, "Wrong alignment on UDynamicRepresentationSubsystem");
static_assert(sizeof(UDynamicRepresentationSubsystem) == 0x000200, "Wrong size on UDynamicRepresentationSubsystem");
static_assert(offsetof(UDynamicRepresentationSubsystem, VisualizationSceneHelperActor) == 0x000178, "Member 'UDynamicRepresentationSubsystem::VisualizationSceneHelperActor' has a wrong offset!");

// Class DynamicRepresentation.SimpleAssetsStreamingDataAsset
// 0x0010 (0x0040 - 0x0030)
class USimpleAssetsStreamingDataAsset final : public UPrimaryDataAsset
{
public:
	TArray<TSoftObjectPtr<class UObject>>         Assets;                                            // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SimpleAssetsStreamingDataAsset">();
	}
	static class USimpleAssetsStreamingDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<USimpleAssetsStreamingDataAsset>();
	}
};
static_assert(alignof(USimpleAssetsStreamingDataAsset) == 0x000008, "Wrong alignment on USimpleAssetsStreamingDataAsset");
static_assert(sizeof(USimpleAssetsStreamingDataAsset) == 0x000040, "Wrong size on USimpleAssetsStreamingDataAsset");
static_assert(offsetof(USimpleAssetsStreamingDataAsset, Assets) == 0x000030, "Member 'USimpleAssetsStreamingDataAsset::Assets' has a wrong offset!");

// Class DynamicRepresentation.SimpleAssetsStreamingSubsystemInterface
// 0x0000 (0x0000 - 0x0000)
class ISimpleAssetsStreamingSubsystemInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SimpleAssetsStreamingSubsystemInterface">();
	}
	static class ISimpleAssetsStreamingSubsystemInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISimpleAssetsStreamingSubsystemInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ISimpleAssetsStreamingSubsystemInterface) == 0x000001, "Wrong alignment on ISimpleAssetsStreamingSubsystemInterface");
static_assert(sizeof(ISimpleAssetsStreamingSubsystemInterface) == 0x000001, "Wrong size on ISimpleAssetsStreamingSubsystemInterface");

// Class DynamicRepresentation.SimpleAssetsStreamingSubsystem
// 0x0038 (0x0080 - 0x0048)
class alignas(0x10) USimpleAssetsStreamingSubsystem final : public UTickableWorldSubsystem
{
public:
	uint8                                         Pad_48[0x18];                                      // 0x0048(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UObject*>                        AssetsHolder;                                      // 0x0060(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_70[0x10];                                      // 0x0070(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SimpleAssetsStreamingSubsystem">();
	}
	static class USimpleAssetsStreamingSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<USimpleAssetsStreamingSubsystem>();
	}
};
static_assert(alignof(USimpleAssetsStreamingSubsystem) == 0x000010, "Wrong alignment on USimpleAssetsStreamingSubsystem");
static_assert(sizeof(USimpleAssetsStreamingSubsystem) == 0x000080, "Wrong size on USimpleAssetsStreamingSubsystem");
static_assert(offsetof(USimpleAssetsStreamingSubsystem, AssetsHolder) == 0x000060, "Member 'USimpleAssetsStreamingSubsystem::AssetsHolder' has a wrong offset!");

// Class DynamicRepresentation.VisualizationSceneHelperActor
// 0x0008 (0x02E0 - 0x02D8)
class AVisualizationSceneHelperActor final : public AActor
{
public:
	class UDynamicInstanceVisualizationComponent* VisualizationComponent;                            // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VisualizationSceneHelperActor">();
	}
	static class AVisualizationSceneHelperActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVisualizationSceneHelperActor>();
	}
};
static_assert(alignof(AVisualizationSceneHelperActor) == 0x000008, "Wrong alignment on AVisualizationSceneHelperActor");
static_assert(sizeof(AVisualizationSceneHelperActor) == 0x0002E0, "Wrong size on AVisualizationSceneHelperActor");
static_assert(offsetof(AVisualizationSceneHelperActor, VisualizationComponent) == 0x0002D8, "Member 'AVisualizationSceneHelperActor::VisualizationComponent' has a wrong offset!");

}

