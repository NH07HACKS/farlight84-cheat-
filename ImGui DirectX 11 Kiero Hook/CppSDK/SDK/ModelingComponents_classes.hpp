#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: ModelingComponents

#include "Basic.hpp"

#include "Engine_classes.hpp"
#include "ModelingComponents_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "InteractiveToolsFramework_classes.hpp"


namespace SDK
{

// Class ModelingComponents.CollectSurfacePathMechanic
// 0x0520 (0x0550 - 0x0030)
class UCollectSurfacePathMechanic final : public UInteractionMechanic
{
public:
	uint8                                         Pad_30[0x520];                                     // 0x0030(0x0520)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CollectSurfacePathMechanic">();
	}
	static class UCollectSurfacePathMechanic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCollectSurfacePathMechanic>();
	}
};
static_assert(alignof(UCollectSurfacePathMechanic) == 0x000008, "Wrong alignment on UCollectSurfacePathMechanic");
static_assert(sizeof(UCollectSurfacePathMechanic) == 0x000550, "Wrong size on UCollectSurfacePathMechanic");

// Class ModelingComponents.BaseDynamicMeshComponent
// 0x0050 (0x06E0 - 0x0690)
#pragma pack(push, 0x1)
class alignas(0x10) UBaseDynamicMeshComponent : public UMeshComponent
{
public:
	uint8                                         Pad_690[0x48];                                     // 0x0690(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseDynamicMeshComponent">();
	}
	static class UBaseDynamicMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseDynamicMeshComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UBaseDynamicMeshComponent) == 0x000010, "Wrong alignment on UBaseDynamicMeshComponent");
static_assert(sizeof(UBaseDynamicMeshComponent) == 0x0006E0, "Wrong size on UBaseDynamicMeshComponent");

// Class ModelingComponents.ConstructionPlaneMechanic
// 0x00C0 (0x00F0 - 0x0030)
class alignas(0x10) UConstructionPlaneMechanic final : public UInteractionMechanic
{
public:
	uint8                                         Pad_30[0x98];                                      // 0x0030(0x0098)(Fixing Size After Last Property [ Dumper-7 ])
	class UTransformGizmo*                        PlaneTransformGizmo;                               // 0x00C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTransformProxy*                        PlaneTransformProxy;                               // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D8[0x10];                                      // 0x00D8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class USingleClickInputBehavior*              ClickToSetPlaneBehavior;                           // 0x00E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConstructionPlaneMechanic">();
	}
	static class UConstructionPlaneMechanic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConstructionPlaneMechanic>();
	}
};
static_assert(alignof(UConstructionPlaneMechanic) == 0x000010, "Wrong alignment on UConstructionPlaneMechanic");
static_assert(sizeof(UConstructionPlaneMechanic) == 0x0000F0, "Wrong size on UConstructionPlaneMechanic");
static_assert(offsetof(UConstructionPlaneMechanic, PlaneTransformGizmo) == 0x0000C8, "Member 'UConstructionPlaneMechanic::PlaneTransformGizmo' has a wrong offset!");
static_assert(offsetof(UConstructionPlaneMechanic, PlaneTransformProxy) == 0x0000D0, "Member 'UConstructionPlaneMechanic::PlaneTransformProxy' has a wrong offset!");
static_assert(offsetof(UConstructionPlaneMechanic, ClickToSetPlaneBehavior) == 0x0000E8, "Member 'UConstructionPlaneMechanic::ClickToSetPlaneBehavior' has a wrong offset!");

// Class ModelingComponents.SimpleDynamicMeshComponent
// 0x0140 (0x0820 - 0x06E0)
class USimpleDynamicMeshComponent : public UBaseDynamicMeshComponent
{
public:
	EDynamicMeshTangentCalcType                   TangentsType;                                      // 0x06D8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvalidateProxyOnChange;                          // 0x06D9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6DA[0x36];                                     // 0x06DA(0x0036)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bExplicitShowWireframe;                            // 0x0710(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_711[0x4F];                                     // 0x0711(0x004F)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDrawOnTop;                                        // 0x0760(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_761[0xBF];                                     // 0x0761(0x00BF)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SimpleDynamicMeshComponent">();
	}
	static class USimpleDynamicMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USimpleDynamicMeshComponent>();
	}
};
static_assert(alignof(USimpleDynamicMeshComponent) == 0x000010, "Wrong alignment on USimpleDynamicMeshComponent");
static_assert(sizeof(USimpleDynamicMeshComponent) == 0x000820, "Wrong size on USimpleDynamicMeshComponent");
static_assert(offsetof(USimpleDynamicMeshComponent, TangentsType) == 0x0006D8, "Member 'USimpleDynamicMeshComponent::TangentsType' has a wrong offset!");
static_assert(offsetof(USimpleDynamicMeshComponent, bInvalidateProxyOnChange) == 0x0006D9, "Member 'USimpleDynamicMeshComponent::bInvalidateProxyOnChange' has a wrong offset!");
static_assert(offsetof(USimpleDynamicMeshComponent, bExplicitShowWireframe) == 0x000710, "Member 'USimpleDynamicMeshComponent::bExplicitShowWireframe' has a wrong offset!");
static_assert(offsetof(USimpleDynamicMeshComponent, bDrawOnTop) == 0x000760, "Member 'USimpleDynamicMeshComponent::bDrawOnTop' has a wrong offset!");

// Class ModelingComponents.DynamicMeshReplacementChangeTarget
// 0x0030 (0x0058 - 0x0028)
class UDynamicMeshReplacementChangeTarget final : public UObject
{
public:
	uint8                                         Pad_28[0x30];                                      // 0x0028(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicMeshReplacementChangeTarget">();
	}
	static class UDynamicMeshReplacementChangeTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicMeshReplacementChangeTarget>();
	}
};
static_assert(alignof(UDynamicMeshReplacementChangeTarget) == 0x000008, "Wrong alignment on UDynamicMeshReplacementChangeTarget");
static_assert(sizeof(UDynamicMeshReplacementChangeTarget) == 0x000058, "Wrong size on UDynamicMeshReplacementChangeTarget");

// Class ModelingComponents.LineSetComponent
// 0x0060 (0x06F0 - 0x0690)
class ULineSetComponent final : public UMeshComponent
{
public:
	class UMaterialInterface*                     LineMaterial;                                      // 0x0690(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBoxSphereBounds                       Bounds;                                            // 0x0698(0x001C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	bool                                          bBoundsDirty;                                      // 0x06B4(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6B5[0x3B];                                     // 0x06B5(0x003B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LineSetComponent">();
	}
	static class ULineSetComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULineSetComponent>();
	}
};
static_assert(alignof(ULineSetComponent) == 0x000010, "Wrong alignment on ULineSetComponent");
static_assert(sizeof(ULineSetComponent) == 0x0006F0, "Wrong size on ULineSetComponent");
static_assert(offsetof(ULineSetComponent, LineMaterial) == 0x000690, "Member 'ULineSetComponent::LineMaterial' has a wrong offset!");
static_assert(offsetof(ULineSetComponent, Bounds) == 0x000698, "Member 'ULineSetComponent::Bounds' has a wrong offset!");
static_assert(offsetof(ULineSetComponent, bBoundsDirty) == 0x0006B4, "Member 'ULineSetComponent::bBoundsDirty' has a wrong offset!");

// Class ModelingComponents.MeshCommandChangeTarget
// 0x0000 (0x0000 - 0x0000)
class IMeshCommandChangeTarget final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeshCommandChangeTarget">();
	}
	static class IMeshCommandChangeTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMeshCommandChangeTarget>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IMeshCommandChangeTarget) == 0x000001, "Wrong alignment on IMeshCommandChangeTarget");
static_assert(sizeof(IMeshCommandChangeTarget) == 0x000001, "Wrong size on IMeshCommandChangeTarget");

// Class ModelingComponents.MeshOpPreviewWithBackgroundCompute
// 0x0068 (0x0090 - 0x0028)
class UMeshOpPreviewWithBackgroundCompute final : public UObject
{
public:
	uint8                                         Pad_28[0x30];                                      // 0x0028(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UPreviewMesh*                           PreviewMesh;                                       // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMaterialInterface*>             StandardMaterials;                                 // 0x0060(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     OverrideMaterial;                                  // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     WorkingMaterial;                                   // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_80[0x10];                                      // 0x0080(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeshOpPreviewWithBackgroundCompute">();
	}
	static class UMeshOpPreviewWithBackgroundCompute* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeshOpPreviewWithBackgroundCompute>();
	}
};
static_assert(alignof(UMeshOpPreviewWithBackgroundCompute) == 0x000008, "Wrong alignment on UMeshOpPreviewWithBackgroundCompute");
static_assert(sizeof(UMeshOpPreviewWithBackgroundCompute) == 0x000090, "Wrong size on UMeshOpPreviewWithBackgroundCompute");
static_assert(offsetof(UMeshOpPreviewWithBackgroundCompute, PreviewMesh) == 0x000058, "Member 'UMeshOpPreviewWithBackgroundCompute::PreviewMesh' has a wrong offset!");
static_assert(offsetof(UMeshOpPreviewWithBackgroundCompute, StandardMaterials) == 0x000060, "Member 'UMeshOpPreviewWithBackgroundCompute::StandardMaterials' has a wrong offset!");
static_assert(offsetof(UMeshOpPreviewWithBackgroundCompute, OverrideMaterial) == 0x000070, "Member 'UMeshOpPreviewWithBackgroundCompute::OverrideMaterial' has a wrong offset!");
static_assert(offsetof(UMeshOpPreviewWithBackgroundCompute, WorkingMaterial) == 0x000078, "Member 'UMeshOpPreviewWithBackgroundCompute::WorkingMaterial' has a wrong offset!");

// Class ModelingComponents.MeshReplacementCommandChangeTarget
// 0x0000 (0x0000 - 0x0000)
class IMeshReplacementCommandChangeTarget final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeshReplacementCommandChangeTarget">();
	}
	static class IMeshReplacementCommandChangeTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMeshReplacementCommandChangeTarget>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IMeshReplacementCommandChangeTarget) == 0x000001, "Wrong alignment on IMeshReplacementCommandChangeTarget");
static_assert(sizeof(IMeshReplacementCommandChangeTarget) == 0x000001, "Wrong size on IMeshReplacementCommandChangeTarget");

// Class ModelingComponents.MeshVertexCommandChangeTarget
// 0x0000 (0x0000 - 0x0000)
class IMeshVertexCommandChangeTarget final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeshVertexCommandChangeTarget">();
	}
	static class IMeshVertexCommandChangeTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMeshVertexCommandChangeTarget>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IMeshVertexCommandChangeTarget) == 0x000001, "Wrong alignment on IMeshVertexCommandChangeTarget");
static_assert(sizeof(IMeshVertexCommandChangeTarget) == 0x000001, "Wrong size on IMeshVertexCommandChangeTarget");

// Class ModelingComponents.MultiTransformer
// 0x0118 (0x0140 - 0x0028)
class alignas(0x10) UMultiTransformer final : public UObject
{
public:
	uint8                                         Pad_28[0xB0];                                      // 0x0028(0x00B0)(Fixing Size After Last Property [ Dumper-7 ])
	class UTransformGizmo*                        TransformGizmo;                                    // 0x00D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTransformProxy*                        TransformProxy;                                    // 0x00E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E8[0x58];                                      // 0x00E8(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MultiTransformer">();
	}
	static class UMultiTransformer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMultiTransformer>();
	}
};
static_assert(alignof(UMultiTransformer) == 0x000010, "Wrong alignment on UMultiTransformer");
static_assert(sizeof(UMultiTransformer) == 0x000140, "Wrong size on UMultiTransformer");
static_assert(offsetof(UMultiTransformer, TransformGizmo) == 0x0000D8, "Member 'UMultiTransformer::TransformGizmo' has a wrong offset!");
static_assert(offsetof(UMultiTransformer, TransformProxy) == 0x0000E0, "Member 'UMultiTransformer::TransformProxy' has a wrong offset!");

// Class ModelingComponents.OctreeDynamicMeshComponent
// 0x0110 (0x07F0 - 0x06E0)
class UOctreeDynamicMeshComponent final : public UBaseDynamicMeshComponent
{
public:
	uint8                                         Pad_6D8[0x18];                                     // 0x06D8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bExplicitShowWireframe;                            // 0x06F0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6F1[0xFF];                                     // 0x06F1(0x00FF)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OctreeDynamicMeshComponent">();
	}
	static class UOctreeDynamicMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOctreeDynamicMeshComponent>();
	}
};
static_assert(alignof(UOctreeDynamicMeshComponent) == 0x000010, "Wrong alignment on UOctreeDynamicMeshComponent");
static_assert(sizeof(UOctreeDynamicMeshComponent) == 0x0007F0, "Wrong size on UOctreeDynamicMeshComponent");
static_assert(offsetof(UOctreeDynamicMeshComponent, bExplicitShowWireframe) == 0x0006F0, "Member 'UOctreeDynamicMeshComponent::bExplicitShowWireframe' has a wrong offset!");

// Class ModelingComponents.PlaneDistanceFromHitMechanic
// 0x03F0 (0x0420 - 0x0030)
class UPlaneDistanceFromHitMechanic final : public UInteractionMechanic
{
public:
	uint8                                         Pad_30[0x3F0];                                     // 0x0030(0x03F0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlaneDistanceFromHitMechanic">();
	}
	static class UPlaneDistanceFromHitMechanic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlaneDistanceFromHitMechanic>();
	}
};
static_assert(alignof(UPlaneDistanceFromHitMechanic) == 0x000008, "Wrong alignment on UPlaneDistanceFromHitMechanic");
static_assert(sizeof(UPlaneDistanceFromHitMechanic) == 0x000420, "Wrong size on UPlaneDistanceFromHitMechanic");

// Class ModelingComponents.PointSetComponent
// 0x0060 (0x06F0 - 0x0690)
class UPointSetComponent final : public UMeshComponent
{
public:
	class UMaterialInterface*                     PointMaterial;                                     // 0x0690(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBoxSphereBounds                       Bounds;                                            // 0x0698(0x001C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	bool                                          bBoundsDirty;                                      // 0x06B4(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6B5[0x3B];                                     // 0x06B5(0x003B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PointSetComponent">();
	}
	static class UPointSetComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPointSetComponent>();
	}
};
static_assert(alignof(UPointSetComponent) == 0x000010, "Wrong alignment on UPointSetComponent");
static_assert(sizeof(UPointSetComponent) == 0x0006F0, "Wrong size on UPointSetComponent");
static_assert(offsetof(UPointSetComponent, PointMaterial) == 0x000690, "Member 'UPointSetComponent::PointMaterial' has a wrong offset!");
static_assert(offsetof(UPointSetComponent, Bounds) == 0x000698, "Member 'UPointSetComponent::Bounds' has a wrong offset!");
static_assert(offsetof(UPointSetComponent, bBoundsDirty) == 0x0006B4, "Member 'UPointSetComponent::bBoundsDirty' has a wrong offset!");

// Class ModelingComponents.PreviewMesh
// 0x00B8 (0x00E0 - 0x0028)
class UPreviewMesh : public UObject
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bBuildSpatialDataStructure;                        // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawOnTop;                                        // 0x0041(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0xE];                                       // 0x0042(0x000E)(Fixing Size After Last Property [ Dumper-7 ])
	class USimpleDynamicMeshComponent*            DynamicMeshComponent;                              // 0x0050(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_58[0x88];                                      // 0x0058(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PreviewMesh">();
	}
	static class UPreviewMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPreviewMesh>();
	}
};
static_assert(alignof(UPreviewMesh) == 0x000008, "Wrong alignment on UPreviewMesh");
static_assert(sizeof(UPreviewMesh) == 0x0000E0, "Wrong size on UPreviewMesh");
static_assert(offsetof(UPreviewMesh, bBuildSpatialDataStructure) == 0x000040, "Member 'UPreviewMesh::bBuildSpatialDataStructure' has a wrong offset!");
static_assert(offsetof(UPreviewMesh, bDrawOnTop) == 0x000041, "Member 'UPreviewMesh::bDrawOnTop' has a wrong offset!");
static_assert(offsetof(UPreviewMesh, DynamicMeshComponent) == 0x000050, "Member 'UPreviewMesh::DynamicMeshComponent' has a wrong offset!");

// Class ModelingComponents.PolyEditPreviewMesh
// 0x0398 (0x0478 - 0x00E0)
class UPolyEditPreviewMesh final : public UPreviewMesh
{
public:
	uint8                                         Pad_E0[0x398];                                     // 0x00E0(0x0398)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PolyEditPreviewMesh">();
	}
	static class UPolyEditPreviewMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPolyEditPreviewMesh>();
	}
};
static_assert(alignof(UPolyEditPreviewMesh) == 0x000008, "Wrong alignment on UPolyEditPreviewMesh");
static_assert(sizeof(UPolyEditPreviewMesh) == 0x000478, "Wrong size on UPolyEditPreviewMesh");

// Class ModelingComponents.PolygonSelectionMechanicProperties
// 0x0008 (0x0068 - 0x0060)
class UPolygonSelectionMechanicProperties final : public UInteractiveToolPropertySet
{
public:
	bool                                          bSelectFaces;                                      // 0x0060(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSelectEdges;                                      // 0x0061(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSelectVertices;                                   // 0x0062(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_63[0x5];                                       // 0x0063(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PolygonSelectionMechanicProperties">();
	}
	static class UPolygonSelectionMechanicProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPolygonSelectionMechanicProperties>();
	}
};
static_assert(alignof(UPolygonSelectionMechanicProperties) == 0x000008, "Wrong alignment on UPolygonSelectionMechanicProperties");
static_assert(sizeof(UPolygonSelectionMechanicProperties) == 0x000068, "Wrong size on UPolygonSelectionMechanicProperties");
static_assert(offsetof(UPolygonSelectionMechanicProperties, bSelectFaces) == 0x000060, "Member 'UPolygonSelectionMechanicProperties::bSelectFaces' has a wrong offset!");
static_assert(offsetof(UPolygonSelectionMechanicProperties, bSelectEdges) == 0x000061, "Member 'UPolygonSelectionMechanicProperties::bSelectEdges' has a wrong offset!");
static_assert(offsetof(UPolygonSelectionMechanicProperties, bSelectVertices) == 0x000062, "Member 'UPolygonSelectionMechanicProperties::bSelectVertices' has a wrong offset!");

// Class ModelingComponents.PolygonSelectionMechanic
// 0x0590 (0x05C0 - 0x0030)
class alignas(0x10) UPolygonSelectionMechanic final : public UInteractionMechanic
{
public:
	uint8                                         Pad_30[0x20];                                      // 0x0030(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UPolygonSelectionMechanicProperties*    Properties;                                        // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x568];                                     // 0x0058(0x0568)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PolygonSelectionMechanic">();
	}
	static class UPolygonSelectionMechanic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPolygonSelectionMechanic>();
	}
};
static_assert(alignof(UPolygonSelectionMechanic) == 0x000010, "Wrong alignment on UPolygonSelectionMechanic");
static_assert(sizeof(UPolygonSelectionMechanic) == 0x0005C0, "Wrong size on UPolygonSelectionMechanic");
static_assert(offsetof(UPolygonSelectionMechanic, Properties) == 0x000050, "Member 'UPolygonSelectionMechanic::Properties' has a wrong offset!");

// Class ModelingComponents.PreviewMeshActor
// 0x0000 (0x02D8 - 0x02D8)
class APreviewMeshActor final : public AInternalToolFrameworkActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PreviewMeshActor">();
	}
	static class APreviewMeshActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<APreviewMeshActor>();
	}
};
static_assert(alignof(APreviewMeshActor) == 0x000008, "Wrong alignment on APreviewMeshActor");
static_assert(sizeof(APreviewMeshActor) == 0x0002D8, "Wrong size on APreviewMeshActor");

// Class ModelingComponents.SpatialCurveDistanceMechanic
// 0x03D0 (0x0400 - 0x0030)
class USpatialCurveDistanceMechanic final : public UInteractionMechanic
{
public:
	uint8                                         Pad_30[0x3D0];                                     // 0x0030(0x03D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpatialCurveDistanceMechanic">();
	}
	static class USpatialCurveDistanceMechanic* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpatialCurveDistanceMechanic>();
	}
};
static_assert(alignof(USpatialCurveDistanceMechanic) == 0x000008, "Wrong alignment on USpatialCurveDistanceMechanic");
static_assert(sizeof(USpatialCurveDistanceMechanic) == 0x000400, "Wrong size on USpatialCurveDistanceMechanic");

}

