#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_Logic_BattleRoyale

#include "Basic.hpp"

#include "BP_Logic_Framework_classes.hpp"
#include "Engine_structs.hpp"
#include "E_BattleState_BattleRoyale_structs.hpp"
#include "S_EventList_BattleRoyal_structs.hpp"
#include "Solarland_structs.hpp"
#include "E_BattleEvent_BattleRoyale_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "E_PlayerBattleState_BattleRoyale_structs.hpp"


namespace SDK
{

// BlueprintGeneratedClass BP_Logic_BattleRoyale.BP_Logic_BattleRoyale_C
// 0x02C0 (0x04A8 - 0x01E8)
class UBP_Logic_BattleRoyale_C final : public UBP_Logic_Framework_C
{
public:
	struct FPointerToUberGraphFrame               UberGraphFrame_BP_Logic_BattleRoyale_C;            // 0x01E8(0x0008)(ZeroConstructor, Transient, DuplicateTransient)
	int32                                         WaitTime;                                          // 0x01F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_1F4[0x4];                                      // 0x01F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class APlayerStart*>                   WaitinglandStart;                                  // 0x01F8(0x0010)(Edit, BlueprintVisible, DisableEditOnTemplate, DisableEditOnInstance, HasGetValueTypeHash)
	class ABP_GameState_BattleRoyale_C*           GameState;                                         // 0x0208(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TMulticastInlineDelegate<void()>              OnGoInToBattleState;                               // 0x0210(0x0010)(Edit, BlueprintVisible, ZeroConstructor, BlueprintAssignable, BlueprintCallable)
	bool                                          bWarmGame;                                         // 0x0220(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_221[0x7];                                      // 0x0221(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSolarTablesData_WarmGameMode          WarmGameInfo;                                      // 0x0228(0x0078)(Edit, BlueprintVisible, DisableEditOnInstance)
	class UDataTable*                             BattleTimeline;                                    // 0x02A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TMap<int32, struct FS_EventList_BattleRoyal>  EventList;                                         // 0x02A8(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance)
	class UBP_MapInfoComponent_C*                 MapInfo;                                           // 0x02F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         ShrinkIndex;                                       // 0x0300(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_304[0x4];                                      // 0x0304(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ABP_BattleRoylePoisonCircle_C*          PoisonCircle;                                      // 0x0308(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class ABP_SolarBombingManager_C*              BoomingManager;                                    // 0x0310(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	E_BattleState_BattleRoyale                    ModeBattleState;                                   // 0x0318(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_319[0x7];                                      // 0x0319(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        AirDropPosHistoryRecord;                           // 0x0320(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)
	int32                                         AiLevel;                                           // 0x0330(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_334[0x4];                                      // 0x0334(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<E_BattleEvent_BattleRoyale, bool>        ModeEventValid;                                    // 0x0338(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance)
	int32                                         TotalPlayer;                                       // 0x0388(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_38C[0x4];                                      // 0x038C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ABP_ReviveItemManger_BattleRoyale_C*    ReviveManager;                                     // 0x0390(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class ABP_Formula_BattleRoyale_C*             BR_Formula_Manager;                                // 0x0398(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UDataTable*                             UnfetteredAreaTimeline;                            // 0x03A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         TeamMemberCount;                                   // 0x03A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_3AC[0x4];                                      // 0x03AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ASCMPlayerState*>                PlayersQuitOnWaitingLand;                          // 0x03B0(0x0010)(Edit, BlueprintVisible, DisableEditOnTemplate, DisableEditOnInstance, HasGetValueTypeHash)
	int32                                         PlayerCountMax;                                    // 0x03C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bCanSpawnAI;                                       // 0x03C4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_3C5[0x3];                                      // 0x03C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 PoisonCircleClass;                                 // 0x03C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class ABP_DefenderManager_C*                  DefenderManager;                                   // 0x03D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TArray<float>                                 RadiusArr;                                         // 0x03D8(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)
	int32                                         AILevelMax;                                        // 0x03E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_3EC[0x4];                                      // 0x03EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(E_BattleState_BattleRoyale NewState)> BattleStateChanged;          // 0x03F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	int32                                         PlayerCountBattleStart;                            // 0x0400(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         ChestSpawnerID;                                    // 0x0404(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UClass*                                 CelebrateWinnerGAClass;                            // 0x0408(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TArray<float>                                 MinOffsetArr;                                      // 0x0410(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)
	TArray<float>                                 MaxOffsetArr;                                      // 0x0420(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)
	bool                                          EnableUnfetteredArea;                              // 0x0430(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_431[0x7];                                      // 0x0431(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, struct FExpSpringPreSelectData>   ExpSpringTimelineData;                             // 0x0438(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance)
	int32                                         ReviveItemNum;                                     // 0x0488(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         GameplayTime;                                      // 0x048C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsTimelinePaused;                                  // 0x0490(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_491[0x7];                                      // 0x0491(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 PoisonDamageArr;                                   // 0x0498(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)

public:
	void PresettleAll();
	void Custom_Room_Start();
	void PreSettle(class ASCMPlayerState* Player, ESCMPlayerOutType OutType);
	void BattleInitFinished();
	void ReceivePlayerBattleEnd(class ASCMPlayerState* Player, ESCMPlayerOutType OutType);
	bool ReadyToFinal();
	void Buddy_Event(int32 DelaySpawnTime, const class FString& EventIDStr, const struct FGameplayEventFilterConfig& GEFConfig);
	void OnDefenderShowStart();
	void InitSafeArea(TArray<struct FReduceSafeAreaExecutorData>& Array);
	void InitExpSpringPoint(TArray<class FName>& RowNameList, class UDataTable*& BattleTimeline_0);
	void BP_Logic_BattleRoyale_AutoGenFunc();
	void InEnableUnfetteredArea(bool* IsEnable);
	void GetWeaponIDByCharacter(class ASolarCharacter* InCharacter, int32 InSlot, int32* OutWeaponID);
	void SetUnfetteredAreaTimeline();
	void GetPlayerDataTraceByPlayer(class ABattleRoyalePlayerState* InPlayerState, TMap<class FString, class FString>* Map);
	void HandleWinnerTeamPostSlomo(class ASolarTeamInfo* WinnerTeam);
	void HandleWinnerTeamPreSlomo(class ASolarTeamInfo* WinnerTeam);
	void DealTeammateAISettle(class ASolarPlayerState* Player);
	void SendItemToPlayer(class ASolarPlayerState* Player, const TMap<int32, int32>& ItemMap);
	void GetVehicleDataTrace(TMap<class FString, class FString>* Map);
	void Init_Poison_Circle();
	void SetSkillStateByBattleState();
	int32 Get_Shrink_Index();
	void GetWeaponID(int32 ItemID, int32* weaponid);
	void VehicleDataTrace();
	void GetPlayerDataTrace(class ABattleRoyalePlayerState* Player, TMap<class FString, class FString>* Map);
	bool ReceivePlayerReJoinRequest(const class FString& PlayerID, class FString* ErrorMsg);
	void GetAiLevel(class ASolarPlayerState* Target, int32* DefaultDifficultyLevel);
	void Get_Config(class UCFG_BattleRoyale_C** CFG);
	void DataTrace();
	void UpdatePlayerData(class ASolarPlayerState* Target);
	void PreSettleDeal(class ASCMPlayerState* Player, ESCMPlayerOutType OutType);
	void Will_Master_Leaving_Disband_Room(bool* Result);
	void Is_Master_Disbanding_Legal(bool* Result);
	void Is_Kick_Out_Legal(bool* Result);
	void Is_Side_Switch_Legal(bool* Result);
	void BuyResurrectionDeal(class APlayerState* Player);
	void UpdateWinnerData(const class FString& Team);
	bool IsLamster(class ASCMPlayerState* Player, ESCMPlayerOutType Index_0);
	bool CanPlayerBattle(class ASCMPlayerState* Player);
	void UpdateTeamData(const class FString& Team, bool* bAced);
	void GetConiReviveManager(class ABP_ReviveItemManger_BattleRoyale_C** Output_Get);
	void QuitImmediately(ESCMPlayerOutType Index_0, class ASCMPlayerState* InputPin, bool* SendToSettle);
	void Update_Player_Data_Trace(class ASCMPlayerState* PlayerState);
	void Create_Airdrop(int32 ChestID, int32 Num, int32 NoticeId, const struct FGameplayEventFilterConfig& Config, bool IsSuperAirDrop);
	void StartCruising();
	void InitElements();
	void Get_Map_Info(class UBP_MapInfoComponent_C** MapInfo_0);
	void Init_Timeline_Event(class UDataTable*& BattleTimeline_0);
	void Execute_Battle_Event(const struct FS_Event_BattleRoyale& S_Event_BattleRoyale);
	void UpdateBattleState(E_BattleState_BattleRoyale NewState);
	void GetGameState(class ABP_GameState_BattleRoyale_C** Output_Get);
	void GetPlayerStartOnWaitingland(TArray<class APlayerStart*>* PlayerStarts);
	void GetBattleRoyaleMode(class ABP_Mode_BattleRoyale_C** AsBP_SCM_Battle_Royale);
	void InitModeSetting();
	void GMSpawnAI();
	void ReceiveBattleTick(float BattleTime, float DeltaTime);
	void OnDSClose();
	void ReceivePlayerJoinBattle(class ASCMPlayerState* NewPlayer, bool IsAI);
	void OnActiveUnfetteredArea(bool bActive);
	void OnMatchingClosed(const int32 RPCId);
	void Snapshot();
	void VehicleSnapshot();
	void OnSetEventTimelineState(bool IsPause);
	void HandleFinal();
	void HandleMatchHasStarted();
	void ExecuteUbergraph_BP_Logic_BattleRoyale(int32 EntryPoint);

public:
	static class UClass* StaticClass()
	{
		return StaticBPGeneratedClassImpl<"BP_Logic_BattleRoyale_C">();
	}
	static class UBP_Logic_BattleRoyale_C* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBP_Logic_BattleRoyale_C>();
	}
};
static_assert(alignof(UBP_Logic_BattleRoyale_C) == 0x000008, "Wrong alignment on UBP_Logic_BattleRoyale_C");
static_assert(sizeof(UBP_Logic_BattleRoyale_C) == 0x0004A8, "Wrong size on UBP_Logic_BattleRoyale_C");
static_assert(offsetof(UBP_Logic_BattleRoyale_C, UberGraphFrame_BP_Logic_BattleRoyale_C) == 0x0001E8, "Member 'UBP_Logic_BattleRoyale_C::UberGraphFrame_BP_Logic_BattleRoyale_C' has a wrong offset!");
static_assert(offsetof(UBP_Logic_BattleRoyale_C, WaitTime) == 0x0001F0, "Member 'UBP_Logic_BattleRoyale_C::WaitTime' has a wrong offset!");
static_assert(offsetof(UBP_Logic_BattleRoyale_C, WaitinglandStart) == 0x0001F8, "Member 'UBP_Logic_BattleRoyale_C::WaitinglandStart' has a wrong offset!");
static_assert(offsetof(UBP_Logic_BattleRoyale_C, GameState) == 0x000208, "Member 'UBP_Logic_BattleRoyale_C::GameState' has a wrong offset!");
static_assert(offsetof(UBP_Logic_BattleRoyale_C, OnGoInToBattleState) == 0x000210, "Member 'UBP_Logic_BattleRoyale_C::OnGoInToBattleState' has a wrong offset!");
static_assert(offsetof(UBP_Logic_BattleRoyale_C, bWarmGame) == 0x000220, "Member 'UBP_Logic_BattleRoyale_C::bWarmGame' has a wrong offset!");
static_assert(offsetof(UBP_Logic_BattleRoyale_C, WarmGameInfo) == 0x000228, "Member 'UBP_Logic_BattleRoyale_C::WarmGameInfo' has a wrong offset!");
static_assert(offsetof(UBP_Logic_BattleRoyale_C, BattleTimeline) == 0x0002A0, "Member 'UBP_Logic_BattleRoyale_C::BattleTimeline' has a wrong offset!");
static_assert(offsetof(UBP_Logic_BattleRoyale_C, EventList) == 0x0002A8, "Member 'UBP_Logic_BattleRoyale_C::EventList' has a wrong offset!");
static_assert(offsetof(UBP_Logic_BattleRoyale_C, MapInfo) == 0x0002F8, "Member 'UBP_Logic_BattleRoyale_C::MapInfo' has a wrong offset!");
static_assert(offsetof(UBP_Logic_BattleRoyale_C, ShrinkIndex) == 0x000300, "Member 'UBP_Logic_BattleRoyale_C::ShrinkIndex' has a wrong offset!");
static_assert(offsetof(UBP_Logic_BattleRoyale_C, PoisonCircle) == 0x000308, "Member 'UBP_Logic_BattleRoyale_C::PoisonCircle' has a wrong offset!");
static_assert(offsetof(UBP_Logic_BattleRoyale_C, BoomingManager) == 0x000310, "Member 'UBP_Logic_BattleRoyale_C::BoomingManager' has a wrong offset!");
static_assert(offsetof(UBP_Logic_BattleRoyale_C, ModeBattleState) == 0x000318, "Member 'UBP_Logic_BattleRoyale_C::ModeBattleState' has a wrong offset!");
static_assert(offsetof(UBP_Logic_BattleRoyale_C, AirDropPosHistoryRecord) == 0x000320, "Member 'UBP_Logic_BattleRoyale_C::AirDropPosHistoryRecord' has a wrong offset!");
static_assert(offsetof(UBP_Logic_BattleRoyale_C, AiLevel) == 0x000330, "Member 'UBP_Logic_BattleRoyale_C::AiLevel' has a wrong offset!");
static_assert(offsetof(UBP_Logic_BattleRoyale_C, ModeEventValid) == 0x000338, "Member 'UBP_Logic_BattleRoyale_C::ModeEventValid' has a wrong offset!");
static_assert(offsetof(UBP_Logic_BattleRoyale_C, TotalPlayer) == 0x000388, "Member 'UBP_Logic_BattleRoyale_C::TotalPlayer' has a wrong offset!");
static_assert(offsetof(UBP_Logic_BattleRoyale_C, ReviveManager) == 0x000390, "Member 'UBP_Logic_BattleRoyale_C::ReviveManager' has a wrong offset!");
static_assert(offsetof(UBP_Logic_BattleRoyale_C, BR_Formula_Manager) == 0x000398, "Member 'UBP_Logic_BattleRoyale_C::BR_Formula_Manager' has a wrong offset!");
static_assert(offsetof(UBP_Logic_BattleRoyale_C, UnfetteredAreaTimeline) == 0x0003A0, "Member 'UBP_Logic_BattleRoyale_C::UnfetteredAreaTimeline' has a wrong offset!");
static_assert(offsetof(UBP_Logic_BattleRoyale_C, TeamMemberCount) == 0x0003A8, "Member 'UBP_Logic_BattleRoyale_C::TeamMemberCount' has a wrong offset!");
static_assert(offsetof(UBP_Logic_BattleRoyale_C, PlayersQuitOnWaitingLand) == 0x0003B0, "Member 'UBP_Logic_BattleRoyale_C::PlayersQuitOnWaitingLand' has a wrong offset!");
static_assert(offsetof(UBP_Logic_BattleRoyale_C, PlayerCountMax) == 0x0003C0, "Member 'UBP_Logic_BattleRoyale_C::PlayerCountMax' has a wrong offset!");
static_assert(offsetof(UBP_Logic_BattleRoyale_C, bCanSpawnAI) == 0x0003C4, "Member 'UBP_Logic_BattleRoyale_C::bCanSpawnAI' has a wrong offset!");
static_assert(offsetof(UBP_Logic_BattleRoyale_C, PoisonCircleClass) == 0x0003C8, "Member 'UBP_Logic_BattleRoyale_C::PoisonCircleClass' has a wrong offset!");
static_assert(offsetof(UBP_Logic_BattleRoyale_C, DefenderManager) == 0x0003D0, "Member 'UBP_Logic_BattleRoyale_C::DefenderManager' has a wrong offset!");
static_assert(offsetof(UBP_Logic_BattleRoyale_C, RadiusArr) == 0x0003D8, "Member 'UBP_Logic_BattleRoyale_C::RadiusArr' has a wrong offset!");
static_assert(offsetof(UBP_Logic_BattleRoyale_C, AILevelMax) == 0x0003E8, "Member 'UBP_Logic_BattleRoyale_C::AILevelMax' has a wrong offset!");
static_assert(offsetof(UBP_Logic_BattleRoyale_C, BattleStateChanged) == 0x0003F0, "Member 'UBP_Logic_BattleRoyale_C::BattleStateChanged' has a wrong offset!");
static_assert(offsetof(UBP_Logic_BattleRoyale_C, PlayerCountBattleStart) == 0x000400, "Member 'UBP_Logic_BattleRoyale_C::PlayerCountBattleStart' has a wrong offset!");
static_assert(offsetof(UBP_Logic_BattleRoyale_C, ChestSpawnerID) == 0x000404, "Member 'UBP_Logic_BattleRoyale_C::ChestSpawnerID' has a wrong offset!");
static_assert(offsetof(UBP_Logic_BattleRoyale_C, CelebrateWinnerGAClass) == 0x000408, "Member 'UBP_Logic_BattleRoyale_C::CelebrateWinnerGAClass' has a wrong offset!");
static_assert(offsetof(UBP_Logic_BattleRoyale_C, MinOffsetArr) == 0x000410, "Member 'UBP_Logic_BattleRoyale_C::MinOffsetArr' has a wrong offset!");
static_assert(offsetof(UBP_Logic_BattleRoyale_C, MaxOffsetArr) == 0x000420, "Member 'UBP_Logic_BattleRoyale_C::MaxOffsetArr' has a wrong offset!");
static_assert(offsetof(UBP_Logic_BattleRoyale_C, EnableUnfetteredArea) == 0x000430, "Member 'UBP_Logic_BattleRoyale_C::EnableUnfetteredArea' has a wrong offset!");
static_assert(offsetof(UBP_Logic_BattleRoyale_C, ExpSpringTimelineData) == 0x000438, "Member 'UBP_Logic_BattleRoyale_C::ExpSpringTimelineData' has a wrong offset!");
static_assert(offsetof(UBP_Logic_BattleRoyale_C, ReviveItemNum) == 0x000488, "Member 'UBP_Logic_BattleRoyale_C::ReviveItemNum' has a wrong offset!");
static_assert(offsetof(UBP_Logic_BattleRoyale_C, GameplayTime) == 0x00048C, "Member 'UBP_Logic_BattleRoyale_C::GameplayTime' has a wrong offset!");
static_assert(offsetof(UBP_Logic_BattleRoyale_C, IsTimelinePaused) == 0x000490, "Member 'UBP_Logic_BattleRoyale_C::IsTimelinePaused' has a wrong offset!");
static_assert(offsetof(UBP_Logic_BattleRoyale_C, PoisonDamageArr) == 0x000498, "Member 'UBP_Logic_BattleRoyale_C::PoisonDamageArr' has a wrong offset!");

}

