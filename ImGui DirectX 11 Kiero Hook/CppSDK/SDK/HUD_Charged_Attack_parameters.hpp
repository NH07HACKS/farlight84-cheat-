#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: HUD_Charged_Attack

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"


namespace SDK::Params
{

// Function HUD_Charged_Attack.HUD_Charged_Attack_C.ExecuteUbergraph_HUD_Charged_Attack
// 0x0070 (0x0070 - 0x0000)
struct HUD_Charged_Attack_C_ExecuteUbergraph_HUD_Charged_Attack final
{
public:
	int32                                         EntryPoint;                                        // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          K2Node_Event_InbReloadSuccess;                     // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         K2Node_Event_InReloadAmmo_1;                       // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         K2Node_Event_InReservedAmmo_1;                     // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         K2Node_Event_InMaxAmmo_2;                          // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         K2Node_Event_InAmmoProgress_1;                     // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         K2Node_Event_InReservedAmmo;                       // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         K2Node_Event_InMaxAmmo_1;                          // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         K2Node_Event_InAmmoProgress;                       // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          K2Node_Event_InbFirst;                             // 0x0024(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         K2Node_Event_InReloadProgress_1;                   // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         K2Node_Event_InOverloadProgress;                   // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         K2Node_Event_InOverloadWarningRate;                // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          K2Node_Event_InbOverloadState;                     // 0x0034(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         K2Node_Event_InReloadProgress;                     // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         K2Node_Event_InReloadAmmo;                         // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         K2Node_Event_InMaxAmmo;                            // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FLinearColor                           K2Node_Event_InColor;                              // 0x0044(0x0010)(ConstParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          K2Node_Event_InbCharging;                          // 0x0054(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         K2Node_Event_InChargeMode;                         // 0x0058(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         K2Node_Event_InChargeProgress;                     // 0x005C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_IsVisible_ReturnValue;                    // 0x0060(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_Not_PreBool_ReturnValue;                  // 0x0061(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_IsVisible_ReturnValue_1;                  // 0x0062(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_NotEqual_IntInt_ReturnValue;              // 0x0063(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          K2Node_Event_InbQuitState;                         // 0x0064(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          K2Node_Event_bReloadSpeedup;                       // 0x0065(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          K2Node_Event_InbQuitState_1;                       // 0x0066(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_67[0x1];                                       // 0x0067(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class UUserWidget*                            K2Node_Event_InActiveCrosshair;                    // 0x0068(0x0008)(ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(HUD_Charged_Attack_C_ExecuteUbergraph_HUD_Charged_Attack) == 0x000008, "Wrong alignment on HUD_Charged_Attack_C_ExecuteUbergraph_HUD_Charged_Attack");
static_assert(sizeof(HUD_Charged_Attack_C_ExecuteUbergraph_HUD_Charged_Attack) == 0x000070, "Wrong size on HUD_Charged_Attack_C_ExecuteUbergraph_HUD_Charged_Attack");
static_assert(offsetof(HUD_Charged_Attack_C_ExecuteUbergraph_HUD_Charged_Attack, EntryPoint) == 0x000000, "Member 'HUD_Charged_Attack_C_ExecuteUbergraph_HUD_Charged_Attack::EntryPoint' has a wrong offset!");
static_assert(offsetof(HUD_Charged_Attack_C_ExecuteUbergraph_HUD_Charged_Attack, K2Node_Event_InbReloadSuccess) == 0x000004, "Member 'HUD_Charged_Attack_C_ExecuteUbergraph_HUD_Charged_Attack::K2Node_Event_InbReloadSuccess' has a wrong offset!");
static_assert(offsetof(HUD_Charged_Attack_C_ExecuteUbergraph_HUD_Charged_Attack, K2Node_Event_InReloadAmmo_1) == 0x000008, "Member 'HUD_Charged_Attack_C_ExecuteUbergraph_HUD_Charged_Attack::K2Node_Event_InReloadAmmo_1' has a wrong offset!");
static_assert(offsetof(HUD_Charged_Attack_C_ExecuteUbergraph_HUD_Charged_Attack, K2Node_Event_InReservedAmmo_1) == 0x00000C, "Member 'HUD_Charged_Attack_C_ExecuteUbergraph_HUD_Charged_Attack::K2Node_Event_InReservedAmmo_1' has a wrong offset!");
static_assert(offsetof(HUD_Charged_Attack_C_ExecuteUbergraph_HUD_Charged_Attack, K2Node_Event_InMaxAmmo_2) == 0x000010, "Member 'HUD_Charged_Attack_C_ExecuteUbergraph_HUD_Charged_Attack::K2Node_Event_InMaxAmmo_2' has a wrong offset!");
static_assert(offsetof(HUD_Charged_Attack_C_ExecuteUbergraph_HUD_Charged_Attack, K2Node_Event_InAmmoProgress_1) == 0x000014, "Member 'HUD_Charged_Attack_C_ExecuteUbergraph_HUD_Charged_Attack::K2Node_Event_InAmmoProgress_1' has a wrong offset!");
static_assert(offsetof(HUD_Charged_Attack_C_ExecuteUbergraph_HUD_Charged_Attack, K2Node_Event_InReservedAmmo) == 0x000018, "Member 'HUD_Charged_Attack_C_ExecuteUbergraph_HUD_Charged_Attack::K2Node_Event_InReservedAmmo' has a wrong offset!");
static_assert(offsetof(HUD_Charged_Attack_C_ExecuteUbergraph_HUD_Charged_Attack, K2Node_Event_InMaxAmmo_1) == 0x00001C, "Member 'HUD_Charged_Attack_C_ExecuteUbergraph_HUD_Charged_Attack::K2Node_Event_InMaxAmmo_1' has a wrong offset!");
static_assert(offsetof(HUD_Charged_Attack_C_ExecuteUbergraph_HUD_Charged_Attack, K2Node_Event_InAmmoProgress) == 0x000020, "Member 'HUD_Charged_Attack_C_ExecuteUbergraph_HUD_Charged_Attack::K2Node_Event_InAmmoProgress' has a wrong offset!");
static_assert(offsetof(HUD_Charged_Attack_C_ExecuteUbergraph_HUD_Charged_Attack, K2Node_Event_InbFirst) == 0x000024, "Member 'HUD_Charged_Attack_C_ExecuteUbergraph_HUD_Charged_Attack::K2Node_Event_InbFirst' has a wrong offset!");
static_assert(offsetof(HUD_Charged_Attack_C_ExecuteUbergraph_HUD_Charged_Attack, K2Node_Event_InReloadProgress_1) == 0x000028, "Member 'HUD_Charged_Attack_C_ExecuteUbergraph_HUD_Charged_Attack::K2Node_Event_InReloadProgress_1' has a wrong offset!");
static_assert(offsetof(HUD_Charged_Attack_C_ExecuteUbergraph_HUD_Charged_Attack, K2Node_Event_InOverloadProgress) == 0x00002C, "Member 'HUD_Charged_Attack_C_ExecuteUbergraph_HUD_Charged_Attack::K2Node_Event_InOverloadProgress' has a wrong offset!");
static_assert(offsetof(HUD_Charged_Attack_C_ExecuteUbergraph_HUD_Charged_Attack, K2Node_Event_InOverloadWarningRate) == 0x000030, "Member 'HUD_Charged_Attack_C_ExecuteUbergraph_HUD_Charged_Attack::K2Node_Event_InOverloadWarningRate' has a wrong offset!");
static_assert(offsetof(HUD_Charged_Attack_C_ExecuteUbergraph_HUD_Charged_Attack, K2Node_Event_InbOverloadState) == 0x000034, "Member 'HUD_Charged_Attack_C_ExecuteUbergraph_HUD_Charged_Attack::K2Node_Event_InbOverloadState' has a wrong offset!");
static_assert(offsetof(HUD_Charged_Attack_C_ExecuteUbergraph_HUD_Charged_Attack, K2Node_Event_InReloadProgress) == 0x000038, "Member 'HUD_Charged_Attack_C_ExecuteUbergraph_HUD_Charged_Attack::K2Node_Event_InReloadProgress' has a wrong offset!");
static_assert(offsetof(HUD_Charged_Attack_C_ExecuteUbergraph_HUD_Charged_Attack, K2Node_Event_InReloadAmmo) == 0x00003C, "Member 'HUD_Charged_Attack_C_ExecuteUbergraph_HUD_Charged_Attack::K2Node_Event_InReloadAmmo' has a wrong offset!");
static_assert(offsetof(HUD_Charged_Attack_C_ExecuteUbergraph_HUD_Charged_Attack, K2Node_Event_InMaxAmmo) == 0x000040, "Member 'HUD_Charged_Attack_C_ExecuteUbergraph_HUD_Charged_Attack::K2Node_Event_InMaxAmmo' has a wrong offset!");
static_assert(offsetof(HUD_Charged_Attack_C_ExecuteUbergraph_HUD_Charged_Attack, K2Node_Event_InColor) == 0x000044, "Member 'HUD_Charged_Attack_C_ExecuteUbergraph_HUD_Charged_Attack::K2Node_Event_InColor' has a wrong offset!");
static_assert(offsetof(HUD_Charged_Attack_C_ExecuteUbergraph_HUD_Charged_Attack, K2Node_Event_InbCharging) == 0x000054, "Member 'HUD_Charged_Attack_C_ExecuteUbergraph_HUD_Charged_Attack::K2Node_Event_InbCharging' has a wrong offset!");
static_assert(offsetof(HUD_Charged_Attack_C_ExecuteUbergraph_HUD_Charged_Attack, K2Node_Event_InChargeMode) == 0x000058, "Member 'HUD_Charged_Attack_C_ExecuteUbergraph_HUD_Charged_Attack::K2Node_Event_InChargeMode' has a wrong offset!");
static_assert(offsetof(HUD_Charged_Attack_C_ExecuteUbergraph_HUD_Charged_Attack, K2Node_Event_InChargeProgress) == 0x00005C, "Member 'HUD_Charged_Attack_C_ExecuteUbergraph_HUD_Charged_Attack::K2Node_Event_InChargeProgress' has a wrong offset!");
static_assert(offsetof(HUD_Charged_Attack_C_ExecuteUbergraph_HUD_Charged_Attack, CallFunc_IsVisible_ReturnValue) == 0x000060, "Member 'HUD_Charged_Attack_C_ExecuteUbergraph_HUD_Charged_Attack::CallFunc_IsVisible_ReturnValue' has a wrong offset!");
static_assert(offsetof(HUD_Charged_Attack_C_ExecuteUbergraph_HUD_Charged_Attack, CallFunc_Not_PreBool_ReturnValue) == 0x000061, "Member 'HUD_Charged_Attack_C_ExecuteUbergraph_HUD_Charged_Attack::CallFunc_Not_PreBool_ReturnValue' has a wrong offset!");
static_assert(offsetof(HUD_Charged_Attack_C_ExecuteUbergraph_HUD_Charged_Attack, CallFunc_IsVisible_ReturnValue_1) == 0x000062, "Member 'HUD_Charged_Attack_C_ExecuteUbergraph_HUD_Charged_Attack::CallFunc_IsVisible_ReturnValue_1' has a wrong offset!");
static_assert(offsetof(HUD_Charged_Attack_C_ExecuteUbergraph_HUD_Charged_Attack, CallFunc_NotEqual_IntInt_ReturnValue) == 0x000063, "Member 'HUD_Charged_Attack_C_ExecuteUbergraph_HUD_Charged_Attack::CallFunc_NotEqual_IntInt_ReturnValue' has a wrong offset!");
static_assert(offsetof(HUD_Charged_Attack_C_ExecuteUbergraph_HUD_Charged_Attack, K2Node_Event_InbQuitState) == 0x000064, "Member 'HUD_Charged_Attack_C_ExecuteUbergraph_HUD_Charged_Attack::K2Node_Event_InbQuitState' has a wrong offset!");
static_assert(offsetof(HUD_Charged_Attack_C_ExecuteUbergraph_HUD_Charged_Attack, K2Node_Event_bReloadSpeedup) == 0x000065, "Member 'HUD_Charged_Attack_C_ExecuteUbergraph_HUD_Charged_Attack::K2Node_Event_bReloadSpeedup' has a wrong offset!");
static_assert(offsetof(HUD_Charged_Attack_C_ExecuteUbergraph_HUD_Charged_Attack, K2Node_Event_InbQuitState_1) == 0x000066, "Member 'HUD_Charged_Attack_C_ExecuteUbergraph_HUD_Charged_Attack::K2Node_Event_InbQuitState_1' has a wrong offset!");
static_assert(offsetof(HUD_Charged_Attack_C_ExecuteUbergraph_HUD_Charged_Attack, K2Node_Event_InActiveCrosshair) == 0x000068, "Member 'HUD_Charged_Attack_C_ExecuteUbergraph_HUD_Charged_Attack::K2Node_Event_InActiveCrosshair' has a wrong offset!");

// Function HUD_Charged_Attack.HUD_Charged_Attack_C.OnUpdateCharge
// 0x000C (0x000C - 0x0000)
struct HUD_Charged_Attack_C_OnUpdateCharge final
{
public:
	bool                                          InbCharging;                                       // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InChargeMode;                                      // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         InChargeProgress;                                  // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(HUD_Charged_Attack_C_OnUpdateCharge) == 0x000004, "Wrong alignment on HUD_Charged_Attack_C_OnUpdateCharge");
static_assert(sizeof(HUD_Charged_Attack_C_OnUpdateCharge) == 0x00000C, "Wrong size on HUD_Charged_Attack_C_OnUpdateCharge");
static_assert(offsetof(HUD_Charged_Attack_C_OnUpdateCharge, InbCharging) == 0x000000, "Member 'HUD_Charged_Attack_C_OnUpdateCharge::InbCharging' has a wrong offset!");
static_assert(offsetof(HUD_Charged_Attack_C_OnUpdateCharge, InChargeMode) == 0x000004, "Member 'HUD_Charged_Attack_C_OnUpdateCharge::InChargeMode' has a wrong offset!");
static_assert(offsetof(HUD_Charged_Attack_C_OnUpdateCharge, InChargeProgress) == 0x000008, "Member 'HUD_Charged_Attack_C_OnUpdateCharge::InChargeProgress' has a wrong offset!");

// Function HUD_Charged_Attack.HUD_Charged_Attack_C.SetAmmoColor
// 0x0010 (0x0010 - 0x0000)
struct HUD_Charged_Attack_C_SetAmmoColor final
{
public:
	struct FLinearColor                           InColor;                                           // 0x0000(0x0010)(ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(HUD_Charged_Attack_C_SetAmmoColor) == 0x000004, "Wrong alignment on HUD_Charged_Attack_C_SetAmmoColor");
static_assert(sizeof(HUD_Charged_Attack_C_SetAmmoColor) == 0x000010, "Wrong size on HUD_Charged_Attack_C_SetAmmoColor");
static_assert(offsetof(HUD_Charged_Attack_C_SetAmmoColor, InColor) == 0x000000, "Member 'HUD_Charged_Attack_C_SetAmmoColor::InColor' has a wrong offset!");

// Function HUD_Charged_Attack.HUD_Charged_Attack_C.OnUpdateReload
// 0x000C (0x000C - 0x0000)
struct HUD_Charged_Attack_C_OnUpdateReload final
{
public:
	float                                         InReloadProgress;                                  // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         InReloadAmmo;                                      // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         InMaxAmmo;                                         // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(HUD_Charged_Attack_C_OnUpdateReload) == 0x000004, "Wrong alignment on HUD_Charged_Attack_C_OnUpdateReload");
static_assert(sizeof(HUD_Charged_Attack_C_OnUpdateReload) == 0x00000C, "Wrong size on HUD_Charged_Attack_C_OnUpdateReload");
static_assert(offsetof(HUD_Charged_Attack_C_OnUpdateReload, InReloadProgress) == 0x000000, "Member 'HUD_Charged_Attack_C_OnUpdateReload::InReloadProgress' has a wrong offset!");
static_assert(offsetof(HUD_Charged_Attack_C_OnUpdateReload, InReloadAmmo) == 0x000004, "Member 'HUD_Charged_Attack_C_OnUpdateReload::InReloadAmmo' has a wrong offset!");
static_assert(offsetof(HUD_Charged_Attack_C_OnUpdateReload, InMaxAmmo) == 0x000008, "Member 'HUD_Charged_Attack_C_OnUpdateReload::InMaxAmmo' has a wrong offset!");

// Function HUD_Charged_Attack.HUD_Charged_Attack_C.OnUpdateOverload
// 0x000C (0x000C - 0x0000)
struct HUD_Charged_Attack_C_OnUpdateOverload final
{
public:
	float                                         InOverloadProgress;                                // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         InOverloadWarningRate;                             // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          InbOverloadState;                                  // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
};
static_assert(alignof(HUD_Charged_Attack_C_OnUpdateOverload) == 0x000004, "Wrong alignment on HUD_Charged_Attack_C_OnUpdateOverload");
static_assert(sizeof(HUD_Charged_Attack_C_OnUpdateOverload) == 0x00000C, "Wrong size on HUD_Charged_Attack_C_OnUpdateOverload");
static_assert(offsetof(HUD_Charged_Attack_C_OnUpdateOverload, InOverloadProgress) == 0x000000, "Member 'HUD_Charged_Attack_C_OnUpdateOverload::InOverloadProgress' has a wrong offset!");
static_assert(offsetof(HUD_Charged_Attack_C_OnUpdateOverload, InOverloadWarningRate) == 0x000004, "Member 'HUD_Charged_Attack_C_OnUpdateOverload::InOverloadWarningRate' has a wrong offset!");
static_assert(offsetof(HUD_Charged_Attack_C_OnUpdateOverload, InbOverloadState) == 0x000008, "Member 'HUD_Charged_Attack_C_OnUpdateOverload::InbOverloadState' has a wrong offset!");

// Function HUD_Charged_Attack.HUD_Charged_Attack_C.OnUpdateCoolDown
// 0x0004 (0x0004 - 0x0000)
struct HUD_Charged_Attack_C_OnUpdateCoolDown final
{
public:
	float                                         InReloadProgress;                                  // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(HUD_Charged_Attack_C_OnUpdateCoolDown) == 0x000004, "Wrong alignment on HUD_Charged_Attack_C_OnUpdateCoolDown");
static_assert(sizeof(HUD_Charged_Attack_C_OnUpdateCoolDown) == 0x000004, "Wrong size on HUD_Charged_Attack_C_OnUpdateCoolDown");
static_assert(offsetof(HUD_Charged_Attack_C_OnUpdateCoolDown, InReloadProgress) == 0x000000, "Member 'HUD_Charged_Attack_C_OnUpdateCoolDown::InReloadProgress' has a wrong offset!");

// Function HUD_Charged_Attack.HUD_Charged_Attack_C.OnUpdateAmmo
// 0x0010 (0x0010 - 0x0000)
struct HUD_Charged_Attack_C_OnUpdateAmmo final
{
public:
	int32                                         InReservedAmmo;                                    // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         InMaxAmmo;                                         // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         InAmmoProgress;                                    // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          InbFirst;                                          // 0x000C(0x0001)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
};
static_assert(alignof(HUD_Charged_Attack_C_OnUpdateAmmo) == 0x000004, "Wrong alignment on HUD_Charged_Attack_C_OnUpdateAmmo");
static_assert(sizeof(HUD_Charged_Attack_C_OnUpdateAmmo) == 0x000010, "Wrong size on HUD_Charged_Attack_C_OnUpdateAmmo");
static_assert(offsetof(HUD_Charged_Attack_C_OnUpdateAmmo, InReservedAmmo) == 0x000000, "Member 'HUD_Charged_Attack_C_OnUpdateAmmo::InReservedAmmo' has a wrong offset!");
static_assert(offsetof(HUD_Charged_Attack_C_OnUpdateAmmo, InMaxAmmo) == 0x000004, "Member 'HUD_Charged_Attack_C_OnUpdateAmmo::InMaxAmmo' has a wrong offset!");
static_assert(offsetof(HUD_Charged_Attack_C_OnUpdateAmmo, InAmmoProgress) == 0x000008, "Member 'HUD_Charged_Attack_C_OnUpdateAmmo::InAmmoProgress' has a wrong offset!");
static_assert(offsetof(HUD_Charged_Attack_C_OnUpdateAmmo, InbFirst) == 0x00000C, "Member 'HUD_Charged_Attack_C_OnUpdateAmmo::InbFirst' has a wrong offset!");

// Function HUD_Charged_Attack.HUD_Charged_Attack_C.OnReloadFinish
// 0x0014 (0x0014 - 0x0000)
struct HUD_Charged_Attack_C_OnReloadFinish final
{
public:
	bool                                          InbReloadSuccess;                                  // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InReloadAmmo;                                      // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         InReservedAmmo;                                    // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         InMaxAmmo;                                         // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         InAmmoProgress;                                    // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(HUD_Charged_Attack_C_OnReloadFinish) == 0x000004, "Wrong alignment on HUD_Charged_Attack_C_OnReloadFinish");
static_assert(sizeof(HUD_Charged_Attack_C_OnReloadFinish) == 0x000014, "Wrong size on HUD_Charged_Attack_C_OnReloadFinish");
static_assert(offsetof(HUD_Charged_Attack_C_OnReloadFinish, InbReloadSuccess) == 0x000000, "Member 'HUD_Charged_Attack_C_OnReloadFinish::InbReloadSuccess' has a wrong offset!");
static_assert(offsetof(HUD_Charged_Attack_C_OnReloadFinish, InReloadAmmo) == 0x000004, "Member 'HUD_Charged_Attack_C_OnReloadFinish::InReloadAmmo' has a wrong offset!");
static_assert(offsetof(HUD_Charged_Attack_C_OnReloadFinish, InReservedAmmo) == 0x000008, "Member 'HUD_Charged_Attack_C_OnReloadFinish::InReservedAmmo' has a wrong offset!");
static_assert(offsetof(HUD_Charged_Attack_C_OnReloadFinish, InMaxAmmo) == 0x00000C, "Member 'HUD_Charged_Attack_C_OnReloadFinish::InMaxAmmo' has a wrong offset!");
static_assert(offsetof(HUD_Charged_Attack_C_OnReloadFinish, InAmmoProgress) == 0x000010, "Member 'HUD_Charged_Attack_C_OnReloadFinish::InAmmoProgress' has a wrong offset!");

// Function HUD_Charged_Attack.HUD_Charged_Attack_C.OnChangeReloadState
// 0x0002 (0x0002 - 0x0000)
struct HUD_Charged_Attack_C_OnChangeReloadState final
{
public:
	bool                                          InbQuitState;                                      // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          bReloadSpeedup;                                    // 0x0001(0x0001)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
};
static_assert(alignof(HUD_Charged_Attack_C_OnChangeReloadState) == 0x000001, "Wrong alignment on HUD_Charged_Attack_C_OnChangeReloadState");
static_assert(sizeof(HUD_Charged_Attack_C_OnChangeReloadState) == 0x000002, "Wrong size on HUD_Charged_Attack_C_OnChangeReloadState");
static_assert(offsetof(HUD_Charged_Attack_C_OnChangeReloadState, InbQuitState) == 0x000000, "Member 'HUD_Charged_Attack_C_OnChangeReloadState::InbQuitState' has a wrong offset!");
static_assert(offsetof(HUD_Charged_Attack_C_OnChangeReloadState, bReloadSpeedup) == 0x000001, "Member 'HUD_Charged_Attack_C_OnChangeReloadState::bReloadSpeedup' has a wrong offset!");

// Function HUD_Charged_Attack.HUD_Charged_Attack_C.OnChangeOverloadState
// 0x0001 (0x0001 - 0x0000)
struct HUD_Charged_Attack_C_OnChangeOverloadState final
{
public:
	bool                                          InbQuitState;                                      // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
};
static_assert(alignof(HUD_Charged_Attack_C_OnChangeOverloadState) == 0x000001, "Wrong alignment on HUD_Charged_Attack_C_OnChangeOverloadState");
static_assert(sizeof(HUD_Charged_Attack_C_OnChangeOverloadState) == 0x000001, "Wrong size on HUD_Charged_Attack_C_OnChangeOverloadState");
static_assert(offsetof(HUD_Charged_Attack_C_OnChangeOverloadState, InbQuitState) == 0x000000, "Member 'HUD_Charged_Attack_C_OnChangeOverloadState::InbQuitState' has a wrong offset!");

// Function HUD_Charged_Attack.HUD_Charged_Attack_C.OnActiveCrosshair
// 0x0008 (0x0008 - 0x0000)
struct HUD_Charged_Attack_C_OnActiveCrosshair final
{
public:
	class UUserWidget*                            InActiveCrosshair;                                 // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(HUD_Charged_Attack_C_OnActiveCrosshair) == 0x000008, "Wrong alignment on HUD_Charged_Attack_C_OnActiveCrosshair");
static_assert(sizeof(HUD_Charged_Attack_C_OnActiveCrosshair) == 0x000008, "Wrong size on HUD_Charged_Attack_C_OnActiveCrosshair");
static_assert(offsetof(HUD_Charged_Attack_C_OnActiveCrosshair, InActiveCrosshair) == 0x000000, "Member 'HUD_Charged_Attack_C_OnActiveCrosshair::InActiveCrosshair' has a wrong offset!");

// Function HUD_Charged_Attack.HUD_Charged_Attack_C.SetPercent
// 0x0020 (0x0020 - 0x0000)
struct HUD_Charged_Attack_C_SetPercent final
{
public:
	float                                         InPercent;                                         // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         InChargeMode;                                      // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          InbFirstEnter;                                     // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          K2Node_SwitchInteger_CmpSuccess;                   // 0x0009(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UUMGSequencePlayer*                     CallFunc_PlayAnimation_ReturnValue;                // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UUMGSequencePlayer*                     CallFunc_PlayAnimation_ReturnValue_1;              // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(HUD_Charged_Attack_C_SetPercent) == 0x000008, "Wrong alignment on HUD_Charged_Attack_C_SetPercent");
static_assert(sizeof(HUD_Charged_Attack_C_SetPercent) == 0x000020, "Wrong size on HUD_Charged_Attack_C_SetPercent");
static_assert(offsetof(HUD_Charged_Attack_C_SetPercent, InPercent) == 0x000000, "Member 'HUD_Charged_Attack_C_SetPercent::InPercent' has a wrong offset!");
static_assert(offsetof(HUD_Charged_Attack_C_SetPercent, InChargeMode) == 0x000004, "Member 'HUD_Charged_Attack_C_SetPercent::InChargeMode' has a wrong offset!");
static_assert(offsetof(HUD_Charged_Attack_C_SetPercent, InbFirstEnter) == 0x000008, "Member 'HUD_Charged_Attack_C_SetPercent::InbFirstEnter' has a wrong offset!");
static_assert(offsetof(HUD_Charged_Attack_C_SetPercent, K2Node_SwitchInteger_CmpSuccess) == 0x000009, "Member 'HUD_Charged_Attack_C_SetPercent::K2Node_SwitchInteger_CmpSuccess' has a wrong offset!");
static_assert(offsetof(HUD_Charged_Attack_C_SetPercent, CallFunc_PlayAnimation_ReturnValue) == 0x000010, "Member 'HUD_Charged_Attack_C_SetPercent::CallFunc_PlayAnimation_ReturnValue' has a wrong offset!");
static_assert(offsetof(HUD_Charged_Attack_C_SetPercent, CallFunc_PlayAnimation_ReturnValue_1) == 0x000018, "Member 'HUD_Charged_Attack_C_SetPercent::CallFunc_PlayAnimation_ReturnValue_1' has a wrong offset!");

}

