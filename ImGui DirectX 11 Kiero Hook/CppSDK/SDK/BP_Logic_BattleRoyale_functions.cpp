#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_Logic_BattleRoyale

#include "Basic.hpp"

#include "BP_Logic_BattleRoyale_classes.hpp"
#include "BP_Logic_BattleRoyale_parameters.hpp"


namespace SDK
{

// Function BP_Logic_BattleRoyale.BP_Logic_BattleRoyale_C.PresettleAll
// (Public, BlueprintCallable, BlueprintEvent)

void UBP_Logic_BattleRoyale_C::PresettleAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Logic_BattleRoyale_C", "PresettleAll");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Logic_BattleRoyale.BP_Logic_BattleRoyale_C.Custom Room Start
// (Public, BlueprintCallable, BlueprintEvent)

void UBP_Logic_BattleRoyale_C::Custom_Room_Start()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Logic_BattleRoyale_C", "Custom Room Start");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Logic_BattleRoyale.BP_Logic_BattleRoyale_C.PreSettle
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class ASCMPlayerState*                  Player                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// ESCMPlayerOutType                       OutType                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_Logic_BattleRoyale_C::PreSettle(class ASCMPlayerState* Player, ESCMPlayerOutType OutType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Logic_BattleRoyale_C", "PreSettle");

	Params::BP_Logic_BattleRoyale_C_PreSettle Parms{};

	Parms.Player = Player;
	Parms.OutType = OutType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Logic_BattleRoyale.BP_Logic_BattleRoyale_C.BattleInitFinished
// (BlueprintCallable, BlueprintEvent)

void UBP_Logic_BattleRoyale_C::BattleInitFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Logic_BattleRoyale_C", "BattleInitFinished");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Logic_BattleRoyale.BP_Logic_BattleRoyale_C.ReceivePlayerBattleEnd
// (Event, Public, BlueprintEvent)
// Parameters:
// class ASCMPlayerState*                  Player                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// ESCMPlayerOutType                       OutType                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_Logic_BattleRoyale_C::ReceivePlayerBattleEnd(class ASCMPlayerState* Player, ESCMPlayerOutType OutType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Logic_BattleRoyale_C", "ReceivePlayerBattleEnd");

	Params::BP_Logic_BattleRoyale_C_ReceivePlayerBattleEnd Parms{};

	Parms.Player = Player;
	Parms.OutType = OutType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Logic_BattleRoyale.BP_Logic_BattleRoyale_C.ReadyToFinal
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool UBP_Logic_BattleRoyale_C::ReadyToFinal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Logic_BattleRoyale_C", "ReadyToFinal");

	Params::BP_Logic_BattleRoyale_C_ReadyToFinal Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_Logic_BattleRoyale.BP_Logic_BattleRoyale_C.Buddy Event
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   DelaySpawnTime                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const class FString&                    EventIDStr                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)
// const struct FGameplayEventFilterConfig&GEFConfig                                              (BlueprintVisible, BlueprintReadOnly, Parm)

void UBP_Logic_BattleRoyale_C::Buddy_Event(int32 DelaySpawnTime, const class FString& EventIDStr, const struct FGameplayEventFilterConfig& GEFConfig)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Logic_BattleRoyale_C", "Buddy Event");

	Params::BP_Logic_BattleRoyale_C_Buddy_Event Parms{};

	Parms.DelaySpawnTime = DelaySpawnTime;
	Parms.EventIDStr = std::move(EventIDStr);
	Parms.GEFConfig = std::move(GEFConfig);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Logic_BattleRoyale.BP_Logic_BattleRoyale_C.OnDefenderShowStart
// (Public, BlueprintCallable, BlueprintEvent)

void UBP_Logic_BattleRoyale_C::OnDefenderShowStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Logic_BattleRoyale_C", "OnDefenderShowStart");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Logic_BattleRoyale.BP_Logic_BattleRoyale_C.InitSafeArea
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FReduceSafeAreaExecutorData>&Array                                                  (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, HasGetValueTypeHash)

void UBP_Logic_BattleRoyale_C::InitSafeArea(TArray<struct FReduceSafeAreaExecutorData>& Array)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Logic_BattleRoyale_C", "InitSafeArea");

	Params::BP_Logic_BattleRoyale_C_InitSafeArea Parms{};

	Parms.Array = std::move(Array);

	UObject::ProcessEvent(Func, &Parms);

	Array = std::move(Parms.Array);
}


// Function BP_Logic_BattleRoyale.BP_Logic_BattleRoyale_C.InitExpSpringPoint
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class FName>&                    RowNameList                                            (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, HasGetValueTypeHash)
// class UDataTable*&                      BattleTimeline_0                                       (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_Logic_BattleRoyale_C::InitExpSpringPoint(TArray<class FName>& RowNameList, class UDataTable*& BattleTimeline_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Logic_BattleRoyale_C", "InitExpSpringPoint");

	Params::BP_Logic_BattleRoyale_C_InitExpSpringPoint Parms{};

	Parms.RowNameList = std::move(RowNameList);
	Parms.BattleTimeline_0 = BattleTimeline_0;

	UObject::ProcessEvent(Func, &Parms);

	RowNameList = std::move(Parms.RowNameList);
	BattleTimeline_0 = Parms.BattleTimeline_0;
}


// Function BP_Logic_BattleRoyale.BP_Logic_BattleRoyale_C.BP_Logic_BattleRoyale_AutoGenFunc
// (Public, BlueprintCallable, BlueprintEvent)

void UBP_Logic_BattleRoyale_C::BP_Logic_BattleRoyale_AutoGenFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Logic_BattleRoyale_C", "BP_Logic_BattleRoyale_AutoGenFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Logic_BattleRoyale.BP_Logic_BattleRoyale_C.InEnableUnfetteredArea
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   IsEnable                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UBP_Logic_BattleRoyale_C::InEnableUnfetteredArea(bool* IsEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Logic_BattleRoyale_C", "InEnableUnfetteredArea");

	Params::BP_Logic_BattleRoyale_C_InEnableUnfetteredArea Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (IsEnable != nullptr)
		*IsEnable = Parms.IsEnable;
}


// Function BP_Logic_BattleRoyale.BP_Logic_BattleRoyale_C.GetWeaponIDByCharacter
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class ASolarCharacter*                  InCharacter                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   InSlot                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32*                                  OutWeaponID                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_Logic_BattleRoyale_C::GetWeaponIDByCharacter(class ASolarCharacter* InCharacter, int32 InSlot, int32* OutWeaponID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Logic_BattleRoyale_C", "GetWeaponIDByCharacter");

	Params::BP_Logic_BattleRoyale_C_GetWeaponIDByCharacter Parms{};

	Parms.InCharacter = InCharacter;
	Parms.InSlot = InSlot;

	UObject::ProcessEvent(Func, &Parms);

	if (OutWeaponID != nullptr)
		*OutWeaponID = Parms.OutWeaponID;
}


// Function BP_Logic_BattleRoyale.BP_Logic_BattleRoyale_C.SetUnfetteredAreaTimeline
// (Public, BlueprintCallable, BlueprintEvent)

void UBP_Logic_BattleRoyale_C::SetUnfetteredAreaTimeline()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Logic_BattleRoyale_C", "SetUnfetteredAreaTimeline");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Logic_BattleRoyale.BP_Logic_BattleRoyale_C.GetPlayerDataTraceByPlayer
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class ABattleRoyalePlayerState*         InPlayerState                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TMap<class FString, class FString>*     Map                                                    (Parm, OutParm)

void UBP_Logic_BattleRoyale_C::GetPlayerDataTraceByPlayer(class ABattleRoyalePlayerState* InPlayerState, TMap<class FString, class FString>* Map)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Logic_BattleRoyale_C", "GetPlayerDataTraceByPlayer");

	Params::BP_Logic_BattleRoyale_C_GetPlayerDataTraceByPlayer Parms{};

	Parms.InPlayerState = InPlayerState;

	UObject::ProcessEvent(Func, &Parms);

	if (Map != nullptr)
		*Map = std::move(Parms.Map);
}


// Function BP_Logic_BattleRoyale.BP_Logic_BattleRoyale_C.HandleWinnerTeamPostSlomo
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ASolarTeamInfo*                   WinnerTeam                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_Logic_BattleRoyale_C::HandleWinnerTeamPostSlomo(class ASolarTeamInfo* WinnerTeam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Logic_BattleRoyale_C", "HandleWinnerTeamPostSlomo");

	Params::BP_Logic_BattleRoyale_C_HandleWinnerTeamPostSlomo Parms{};

	Parms.WinnerTeam = WinnerTeam;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Logic_BattleRoyale.BP_Logic_BattleRoyale_C.HandleWinnerTeamPreSlomo
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ASolarTeamInfo*                   WinnerTeam                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_Logic_BattleRoyale_C::HandleWinnerTeamPreSlomo(class ASolarTeamInfo* WinnerTeam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Logic_BattleRoyale_C", "HandleWinnerTeamPreSlomo");

	Params::BP_Logic_BattleRoyale_C_HandleWinnerTeamPreSlomo Parms{};

	Parms.WinnerTeam = WinnerTeam;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Logic_BattleRoyale.BP_Logic_BattleRoyale_C.DealTeammateAISettle
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ASolarPlayerState*                Player                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_Logic_BattleRoyale_C::DealTeammateAISettle(class ASolarPlayerState* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Logic_BattleRoyale_C", "DealTeammateAISettle");

	Params::BP_Logic_BattleRoyale_C_DealTeammateAISettle Parms{};

	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Logic_BattleRoyale.BP_Logic_BattleRoyale_C.SendItemToPlayer
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ASolarPlayerState*                Player                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const TMap<int32, int32>&               ItemMap                                                (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void UBP_Logic_BattleRoyale_C::SendItemToPlayer(class ASolarPlayerState* Player, const TMap<int32, int32>& ItemMap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Logic_BattleRoyale_C", "SendItemToPlayer");

	Params::BP_Logic_BattleRoyale_C_SendItemToPlayer Parms{};

	Parms.Player = Player;
	Parms.ItemMap = std::move(ItemMap);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Logic_BattleRoyale.BP_Logic_BattleRoyale_C.GetVehicleDataTrace
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TMap<class FString, class FString>*     Map                                                    (ConstParm, Parm, OutParm)

void UBP_Logic_BattleRoyale_C::GetVehicleDataTrace(TMap<class FString, class FString>* Map)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Logic_BattleRoyale_C", "GetVehicleDataTrace");

	Params::BP_Logic_BattleRoyale_C_GetVehicleDataTrace Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Map != nullptr)
		*Map = std::move(Parms.Map);
}


// Function BP_Logic_BattleRoyale.BP_Logic_BattleRoyale_C.Init Poison Circle
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UBP_Logic_BattleRoyale_C::Init_Poison_Circle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Logic_BattleRoyale_C", "Init Poison Circle");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Logic_BattleRoyale.BP_Logic_BattleRoyale_C.SetSkillStateByBattleState
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UBP_Logic_BattleRoyale_C::SetSkillStateByBattleState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Logic_BattleRoyale_C", "SetSkillStateByBattleState");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Logic_BattleRoyale.BP_Logic_BattleRoyale_C.Get Shrink Index
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

int32 UBP_Logic_BattleRoyale_C::Get_Shrink_Index()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Logic_BattleRoyale_C", "Get Shrink Index");

	Params::BP_Logic_BattleRoyale_C_Get_Shrink_Index Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_Logic_BattleRoyale.BP_Logic_BattleRoyale_C.GetWeaponID
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   ItemID                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32*                                  weaponid                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_Logic_BattleRoyale_C::GetWeaponID(int32 ItemID, int32* weaponid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Logic_BattleRoyale_C", "GetWeaponID");

	Params::BP_Logic_BattleRoyale_C_GetWeaponID Parms{};

	Parms.ItemID = ItemID;

	UObject::ProcessEvent(Func, &Parms);

	if (weaponid != nullptr)
		*weaponid = Parms.weaponid;
}


// Function BP_Logic_BattleRoyale.BP_Logic_BattleRoyale_C.VehicleDataTrace
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UBP_Logic_BattleRoyale_C::VehicleDataTrace()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Logic_BattleRoyale_C", "VehicleDataTrace");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Logic_BattleRoyale.BP_Logic_BattleRoyale_C.GetPlayerDataTrace
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class ABattleRoyalePlayerState*         Player                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TMap<class FString, class FString>*     Map                                                    (Parm, OutParm)

void UBP_Logic_BattleRoyale_C::GetPlayerDataTrace(class ABattleRoyalePlayerState* Player, TMap<class FString, class FString>* Map)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Logic_BattleRoyale_C", "GetPlayerDataTrace");

	Params::BP_Logic_BattleRoyale_C_GetPlayerDataTrace Parms{};

	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);

	if (Map != nullptr)
		*Map = std::move(Parms.Map);
}


// Function BP_Logic_BattleRoyale.BP_Logic_BattleRoyale_C.ReceivePlayerReJoinRequest
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class FString&                    PlayerID                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)
// class FString*                          ErrorMsg                                               (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool UBP_Logic_BattleRoyale_C::ReceivePlayerReJoinRequest(const class FString& PlayerID, class FString* ErrorMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Logic_BattleRoyale_C", "ReceivePlayerReJoinRequest");

	Params::BP_Logic_BattleRoyale_C_ReceivePlayerReJoinRequest Parms{};

	Parms.PlayerID = std::move(PlayerID);

	UObject::ProcessEvent(Func, &Parms);

	if (ErrorMsg != nullptr)
		*ErrorMsg = std::move(Parms.ErrorMsg);

	return Parms.ReturnValue;
}


// Function BP_Logic_BattleRoyale.BP_Logic_BattleRoyale_C.GetAiLevel
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class ASolarPlayerState*                Target                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32*                                  DefaultDifficultyLevel                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_Logic_BattleRoyale_C::GetAiLevel(class ASolarPlayerState* Target, int32* DefaultDifficultyLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Logic_BattleRoyale_C", "GetAiLevel");

	Params::BP_Logic_BattleRoyale_C_GetAiLevel Parms{};

	Parms.Target = Target;

	UObject::ProcessEvent(Func, &Parms);

	if (DefaultDifficultyLevel != nullptr)
		*DefaultDifficultyLevel = Parms.DefaultDifficultyLevel;
}


// Function BP_Logic_BattleRoyale.BP_Logic_BattleRoyale_C.Get Config
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UCFG_BattleRoyale_C**             CFG                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_Logic_BattleRoyale_C::Get_Config(class UCFG_BattleRoyale_C** CFG)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Logic_BattleRoyale_C", "Get Config");

	Params::BP_Logic_BattleRoyale_C_Get_Config Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (CFG != nullptr)
		*CFG = Parms.CFG;
}


// Function BP_Logic_BattleRoyale.BP_Logic_BattleRoyale_C.DataTrace
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UBP_Logic_BattleRoyale_C::DataTrace()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Logic_BattleRoyale_C", "DataTrace");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Logic_BattleRoyale.BP_Logic_BattleRoyale_C.UpdatePlayerData
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ASolarPlayerState*                Target                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_Logic_BattleRoyale_C::UpdatePlayerData(class ASolarPlayerState* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Logic_BattleRoyale_C", "UpdatePlayerData");

	Params::BP_Logic_BattleRoyale_C_UpdatePlayerData Parms{};

	Parms.Target = Target;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Logic_BattleRoyale.BP_Logic_BattleRoyale_C.PreSettleDeal
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ASCMPlayerState*                  Player                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// ESCMPlayerOutType                       OutType                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_Logic_BattleRoyale_C::PreSettleDeal(class ASCMPlayerState* Player, ESCMPlayerOutType OutType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Logic_BattleRoyale_C", "PreSettleDeal");

	Params::BP_Logic_BattleRoyale_C_PreSettleDeal Parms{};

	Parms.Player = Player;
	Parms.OutType = OutType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Logic_BattleRoyale.BP_Logic_BattleRoyale_C.Will Master Leaving Disband Room
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool*                                   Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UBP_Logic_BattleRoyale_C::Will_Master_Leaving_Disband_Room(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Logic_BattleRoyale_C", "Will Master Leaving Disband Room");

	Params::BP_Logic_BattleRoyale_C_Will_Master_Leaving_Disband_Room Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function BP_Logic_BattleRoyale.BP_Logic_BattleRoyale_C.Is Master Disbanding Legal
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool*                                   Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UBP_Logic_BattleRoyale_C::Is_Master_Disbanding_Legal(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Logic_BattleRoyale_C", "Is Master Disbanding Legal");

	Params::BP_Logic_BattleRoyale_C_Is_Master_Disbanding_Legal Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function BP_Logic_BattleRoyale.BP_Logic_BattleRoyale_C.Is Kick Out Legal
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool*                                   Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UBP_Logic_BattleRoyale_C::Is_Kick_Out_Legal(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Logic_BattleRoyale_C", "Is Kick Out Legal");

	Params::BP_Logic_BattleRoyale_C_Is_Kick_Out_Legal Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function BP_Logic_BattleRoyale.BP_Logic_BattleRoyale_C.Is Side Switch Legal
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool*                                   Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UBP_Logic_BattleRoyale_C::Is_Side_Switch_Legal(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Logic_BattleRoyale_C", "Is Side Switch Legal");

	Params::BP_Logic_BattleRoyale_C_Is_Side_Switch_Legal Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function BP_Logic_BattleRoyale.BP_Logic_BattleRoyale_C.BuyResurrectionDeal
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APlayerState*                     Player                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_Logic_BattleRoyale_C::BuyResurrectionDeal(class APlayerState* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Logic_BattleRoyale_C", "BuyResurrectionDeal");

	Params::BP_Logic_BattleRoyale_C_BuyResurrectionDeal Parms{};

	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Logic_BattleRoyale.BP_Logic_BattleRoyale_C.UpdateWinnerData
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class FString&                    Team                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)

void UBP_Logic_BattleRoyale_C::UpdateWinnerData(const class FString& Team)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Logic_BattleRoyale_C", "UpdateWinnerData");

	Params::BP_Logic_BattleRoyale_C_UpdateWinnerData Parms{};

	Parms.Team = std::move(Team);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Logic_BattleRoyale.BP_Logic_BattleRoyale_C.IsLamster
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class ASCMPlayerState*                  Player                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// ESCMPlayerOutType                       Index_0                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool UBP_Logic_BattleRoyale_C::IsLamster(class ASCMPlayerState* Player, ESCMPlayerOutType Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Logic_BattleRoyale_C", "IsLamster");

	Params::BP_Logic_BattleRoyale_C_IsLamster Parms{};

	Parms.Player = Player;
	Parms.Index_0 = Index_0;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_Logic_BattleRoyale.BP_Logic_BattleRoyale_C.CanPlayerBattle
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class ASCMPlayerState*                  Player                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool UBP_Logic_BattleRoyale_C::CanPlayerBattle(class ASCMPlayerState* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Logic_BattleRoyale_C", "CanPlayerBattle");

	Params::BP_Logic_BattleRoyale_C_CanPlayerBattle Parms{};

	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_Logic_BattleRoyale.BP_Logic_BattleRoyale_C.UpdateTeamData
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class FString&                    Team                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)
// bool*                                   bAced                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UBP_Logic_BattleRoyale_C::UpdateTeamData(const class FString& Team, bool* bAced)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Logic_BattleRoyale_C", "UpdateTeamData");

	Params::BP_Logic_BattleRoyale_C_UpdateTeamData Parms{};

	Parms.Team = std::move(Team);

	UObject::ProcessEvent(Func, &Parms);

	if (bAced != nullptr)
		*bAced = Parms.bAced;
}


// Function BP_Logic_BattleRoyale.BP_Logic_BattleRoyale_C.GetConiReviveManager
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class ABP_ReviveItemManger_BattleRoyale_C**Output_Get                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_Logic_BattleRoyale_C::GetConiReviveManager(class ABP_ReviveItemManger_BattleRoyale_C** Output_Get)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Logic_BattleRoyale_C", "GetConiReviveManager");

	Params::BP_Logic_BattleRoyale_C_GetConiReviveManager Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Output_Get != nullptr)
		*Output_Get = Parms.Output_Get;
}


// Function BP_Logic_BattleRoyale.BP_Logic_BattleRoyale_C.QuitImmediately
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// ESCMPlayerOutType                       Index_0                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class ASCMPlayerState*                  InputPin                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   SendToSettle                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UBP_Logic_BattleRoyale_C::QuitImmediately(ESCMPlayerOutType Index_0, class ASCMPlayerState* InputPin, bool* SendToSettle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Logic_BattleRoyale_C", "QuitImmediately");

	Params::BP_Logic_BattleRoyale_C_QuitImmediately Parms{};

	Parms.Index_0 = Index_0;
	Parms.InputPin = InputPin;

	UObject::ProcessEvent(Func, &Parms);

	if (SendToSettle != nullptr)
		*SendToSettle = Parms.SendToSettle;
}


// Function BP_Logic_BattleRoyale.BP_Logic_BattleRoyale_C.Update Player Data Trace
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ASCMPlayerState*                  PlayerState                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_Logic_BattleRoyale_C::Update_Player_Data_Trace(class ASCMPlayerState* PlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Logic_BattleRoyale_C", "Update Player Data Trace");

	Params::BP_Logic_BattleRoyale_C_Update_Player_Data_Trace Parms{};

	Parms.PlayerState = PlayerState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Logic_BattleRoyale.BP_Logic_BattleRoyale_C.Create Airdrop
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   ChestID                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Num                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   NoticeId                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FGameplayEventFilterConfig&Config                                                 (BlueprintVisible, BlueprintReadOnly, Parm)
// bool                                    IsSuperAirDrop                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UBP_Logic_BattleRoyale_C::Create_Airdrop(int32 ChestID, int32 Num, int32 NoticeId, const struct FGameplayEventFilterConfig& Config, bool IsSuperAirDrop)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Logic_BattleRoyale_C", "Create Airdrop");

	Params::BP_Logic_BattleRoyale_C_Create_Airdrop Parms{};

	Parms.ChestID = ChestID;
	Parms.Num = Num;
	Parms.NoticeId = NoticeId;
	Parms.Config = std::move(Config);
	Parms.IsSuperAirDrop = IsSuperAirDrop;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Logic_BattleRoyale.BP_Logic_BattleRoyale_C.StartCruising
// (Public, BlueprintCallable, BlueprintEvent)

void UBP_Logic_BattleRoyale_C::StartCruising()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Logic_BattleRoyale_C", "StartCruising");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Logic_BattleRoyale.BP_Logic_BattleRoyale_C.InitElements
// (Private, HasDefaults, BlueprintCallable, BlueprintEvent)

void UBP_Logic_BattleRoyale_C::InitElements()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Logic_BattleRoyale_C", "InitElements");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Logic_BattleRoyale.BP_Logic_BattleRoyale_C.Get Map Info
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UBP_MapInfoComponent_C**          MapInfo_0                                              (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_Logic_BattleRoyale_C::Get_Map_Info(class UBP_MapInfoComponent_C** MapInfo_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Logic_BattleRoyale_C", "Get Map Info");

	Params::BP_Logic_BattleRoyale_C_Get_Map_Info Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (MapInfo_0 != nullptr)
		*MapInfo_0 = Parms.MapInfo_0;
}


// Function BP_Logic_BattleRoyale.BP_Logic_BattleRoyale_C.Init Timeline Event
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UDataTable*&                      BattleTimeline_0                                       (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_Logic_BattleRoyale_C::Init_Timeline_Event(class UDataTable*& BattleTimeline_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Logic_BattleRoyale_C", "Init Timeline Event");

	Params::BP_Logic_BattleRoyale_C_Init_Timeline_Event Parms{};

	Parms.BattleTimeline_0 = BattleTimeline_0;

	UObject::ProcessEvent(Func, &Parms);

	BattleTimeline_0 = Parms.BattleTimeline_0;
}


// Function BP_Logic_BattleRoyale.BP_Logic_BattleRoyale_C.Execute Battle Event
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FS_Event_BattleRoyale&     S_Event_BattleRoyale                                   (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, HasGetValueTypeHash)

void UBP_Logic_BattleRoyale_C::Execute_Battle_Event(const struct FS_Event_BattleRoyale& S_Event_BattleRoyale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Logic_BattleRoyale_C", "Execute Battle Event");

	Params::BP_Logic_BattleRoyale_C_Execute_Battle_Event Parms{};

	Parms.S_Event_BattleRoyale = std::move(S_Event_BattleRoyale);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Logic_BattleRoyale.BP_Logic_BattleRoyale_C.UpdateBattleState
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_BattleState_BattleRoyale              NewState                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_Logic_BattleRoyale_C::UpdateBattleState(E_BattleState_BattleRoyale NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Logic_BattleRoyale_C", "UpdateBattleState");

	Params::BP_Logic_BattleRoyale_C_UpdateBattleState Parms{};

	Parms.NewState = NewState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Logic_BattleRoyale.BP_Logic_BattleRoyale_C.GetGameState
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class ABP_GameState_BattleRoyale_C**    Output_Get                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_Logic_BattleRoyale_C::GetGameState(class ABP_GameState_BattleRoyale_C** Output_Get)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Logic_BattleRoyale_C", "GetGameState");

	Params::BP_Logic_BattleRoyale_C_GetGameState Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Output_Get != nullptr)
		*Output_Get = Parms.Output_Get;
}


// Function BP_Logic_BattleRoyale.BP_Logic_BattleRoyale_C.GetPlayerStartOnWaitingland
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TArray<class APlayerStart*>*            PlayerStarts                                           (Parm, OutParm, HasGetValueTypeHash)

void UBP_Logic_BattleRoyale_C::GetPlayerStartOnWaitingland(TArray<class APlayerStart*>* PlayerStarts)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Logic_BattleRoyale_C", "GetPlayerStartOnWaitingland");

	Params::BP_Logic_BattleRoyale_C_GetPlayerStartOnWaitingland Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (PlayerStarts != nullptr)
		*PlayerStarts = std::move(Parms.PlayerStarts);
}


// Function BP_Logic_BattleRoyale.BP_Logic_BattleRoyale_C.GetBattleRoyaleMode
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class ABP_Mode_BattleRoyale_C**         AsBP_SCM_Battle_Royale                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_Logic_BattleRoyale_C::GetBattleRoyaleMode(class ABP_Mode_BattleRoyale_C** AsBP_SCM_Battle_Royale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Logic_BattleRoyale_C", "GetBattleRoyaleMode");

	Params::BP_Logic_BattleRoyale_C_GetBattleRoyaleMode Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (AsBP_SCM_Battle_Royale != nullptr)
		*AsBP_SCM_Battle_Royale = Parms.AsBP_SCM_Battle_Royale;
}


// Function BP_Logic_BattleRoyale.BP_Logic_BattleRoyale_C.InitModeSetting
// (Protected, HasDefaults, BlueprintCallable, BlueprintEvent)

void UBP_Logic_BattleRoyale_C::InitModeSetting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Logic_BattleRoyale_C", "InitModeSetting");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Logic_BattleRoyale.BP_Logic_BattleRoyale_C.GMSpawnAI
// (BlueprintCallable, BlueprintEvent)

void UBP_Logic_BattleRoyale_C::GMSpawnAI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Logic_BattleRoyale_C", "GMSpawnAI");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Logic_BattleRoyale.BP_Logic_BattleRoyale_C.ReceiveBattleTick
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   BattleTime                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   DeltaTime                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_Logic_BattleRoyale_C::ReceiveBattleTick(float BattleTime, float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Logic_BattleRoyale_C", "ReceiveBattleTick");

	Params::BP_Logic_BattleRoyale_C_ReceiveBattleTick Parms{};

	Parms.BattleTime = BattleTime;
	Parms.DeltaTime = DeltaTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Logic_BattleRoyale.BP_Logic_BattleRoyale_C.OnDSClose
// (Event, Public, BlueprintEvent)

void UBP_Logic_BattleRoyale_C::OnDSClose()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Logic_BattleRoyale_C", "OnDSClose");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Logic_BattleRoyale.BP_Logic_BattleRoyale_C.ReceivePlayerJoinBattle
// (Event, Public, BlueprintEvent)
// Parameters:
// class ASCMPlayerState*                  NewPlayer                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IsAI                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UBP_Logic_BattleRoyale_C::ReceivePlayerJoinBattle(class ASCMPlayerState* NewPlayer, bool IsAI)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Logic_BattleRoyale_C", "ReceivePlayerJoinBattle");

	Params::BP_Logic_BattleRoyale_C_ReceivePlayerJoinBattle Parms{};

	Parms.NewPlayer = NewPlayer;
	Parms.IsAI = IsAI;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Logic_BattleRoyale.BP_Logic_BattleRoyale_C.OnActiveUnfetteredArea
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bActive                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UBP_Logic_BattleRoyale_C::OnActiveUnfetteredArea(bool bActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Logic_BattleRoyale_C", "OnActiveUnfetteredArea");

	Params::BP_Logic_BattleRoyale_C_OnActiveUnfetteredArea Parms{};

	Parms.bActive = bActive;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Logic_BattleRoyale.BP_Logic_BattleRoyale_C.OnMatchingClosed
// (Event, Public, BlueprintEvent)
// Parameters:
// const int32                             RPCId                                                  (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_Logic_BattleRoyale_C::OnMatchingClosed(const int32 RPCId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Logic_BattleRoyale_C", "OnMatchingClosed");

	Params::BP_Logic_BattleRoyale_C_OnMatchingClosed Parms{};

	Parms.RPCId = RPCId;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Logic_BattleRoyale.BP_Logic_BattleRoyale_C.Snapshot
// (BlueprintCallable, BlueprintEvent)

void UBP_Logic_BattleRoyale_C::Snapshot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Logic_BattleRoyale_C", "Snapshot");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Logic_BattleRoyale.BP_Logic_BattleRoyale_C.VehicleSnapshot
// (BlueprintCallable, BlueprintEvent)

void UBP_Logic_BattleRoyale_C::VehicleSnapshot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Logic_BattleRoyale_C", "VehicleSnapshot");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Logic_BattleRoyale.BP_Logic_BattleRoyale_C.OnSetEventTimelineState
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    IsPause                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UBP_Logic_BattleRoyale_C::OnSetEventTimelineState(bool IsPause)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Logic_BattleRoyale_C", "OnSetEventTimelineState");

	Params::BP_Logic_BattleRoyale_C_OnSetEventTimelineState Parms{};

	Parms.IsPause = IsPause;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Logic_BattleRoyale.BP_Logic_BattleRoyale_C.HandleFinal
// (BlueprintCallable, BlueprintEvent)

void UBP_Logic_BattleRoyale_C::HandleFinal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Logic_BattleRoyale_C", "HandleFinal");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Logic_BattleRoyale.BP_Logic_BattleRoyale_C.HandleMatchHasStarted
// (Event, Public, BlueprintEvent)

void UBP_Logic_BattleRoyale_C::HandleMatchHasStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Logic_BattleRoyale_C", "HandleMatchHasStarted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Logic_BattleRoyale.BP_Logic_BattleRoyale_C.ExecuteUbergraph_BP_Logic_BattleRoyale
// (Final, UbergraphFunction, HasDefaults)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_Logic_BattleRoyale_C::ExecuteUbergraph_BP_Logic_BattleRoyale(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Logic_BattleRoyale_C", "ExecuteUbergraph_BP_Logic_BattleRoyale");

	Params::BP_Logic_BattleRoyale_C_ExecuteUbergraph_BP_Logic_BattleRoyale Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}

}

