#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: RuntimeGeometryUtils

#include "Basic.hpp"

#include "RuntimeGeometryUtils_classes.hpp"
#include "RuntimeGeometryUtils_parameters.hpp"


namespace SDK
{

// Function RuntimeGeometryUtils.SolarBaseDynamicMeshComponent.GetTriangleCount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USolarBaseDynamicMeshComponent::GetTriangleCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SolarBaseDynamicMeshComponent", "GetTriangleCount");

	Params::SolarBaseDynamicMeshComponent_GetTriangleCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RuntimeGeometryUtils.SolarBaseDynamicMeshComponent.UpdateMeshWithTag
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName*                            NewTag                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USolarBaseDynamicMeshComponent::UpdateMeshWithTag(class FName* NewTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SolarBaseDynamicMeshComponent", "UpdateMeshWithTag");

	Params::SolarBaseDynamicMeshComponent_UpdateMeshWithTag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (NewTag != nullptr)
		*NewTag = Parms.NewTag;
}


// Function RuntimeGeometryUtils.DynamicMeshBaseActor.BooleanWithMesh
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ADynamicMeshBaseActor*            OtherMesh                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDynamicMeshActorBooleanOperation       Operation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADynamicMeshBaseActor::BooleanWithMesh(class ADynamicMeshBaseActor* OtherMesh, EDynamicMeshActorBooleanOperation Operation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DynamicMeshBaseActor", "BooleanWithMesh");

	Params::DynamicMeshBaseActor_BooleanWithMesh Parms{};

	Parms.OtherMesh = OtherMesh;
	Parms.Operation = Operation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeGeometryUtils.DynamicMeshBaseActor.ContainsPoint
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   WorldPoint                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   WindingThreshold                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADynamicMeshBaseActor::ContainsPoint(const struct FVector& WorldPoint, float WindingThreshold)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DynamicMeshBaseActor", "ContainsPoint");

	Params::DynamicMeshBaseActor_ContainsPoint Parms{};

	Parms.WorldPoint = std::move(WorldPoint);
	Parms.WindingThreshold = WindingThreshold;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RuntimeGeometryUtils.DynamicMeshBaseActor.CopyFromMesh
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ADynamicMeshBaseActor*            OtherMesh                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRecomputeNormals                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADynamicMeshBaseActor::CopyFromMesh(class ADynamicMeshBaseActor* OtherMesh, bool bRecomputeNormals)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DynamicMeshBaseActor", "CopyFromMesh");

	Params::DynamicMeshBaseActor_CopyFromMesh Parms{};

	Parms.OtherMesh = OtherMesh;
	Parms.bRecomputeNormals = bRecomputeNormals;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeGeometryUtils.DynamicMeshBaseActor.DistanceToPoint
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   WorldPoint                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         NearestMeshWorldPoint                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  NearestTriangle                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         TriBaryCoords                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADynamicMeshBaseActor::DistanceToPoint(const struct FVector& WorldPoint, struct FVector* NearestMeshWorldPoint, int32* NearestTriangle, struct FVector* TriBaryCoords)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DynamicMeshBaseActor", "DistanceToPoint");

	Params::DynamicMeshBaseActor_DistanceToPoint Parms{};

	Parms.WorldPoint = std::move(WorldPoint);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (NearestMeshWorldPoint != nullptr)
		*NearestMeshWorldPoint = std::move(Parms.NearestMeshWorldPoint);

	if (NearestTriangle != nullptr)
		*NearestTriangle = Parms.NearestTriangle;

	if (TriBaryCoords != nullptr)
		*TriBaryCoords = std::move(Parms.TriBaryCoords);

	return Parms.ReturnValue;
}


// Function RuntimeGeometryUtils.DynamicMeshBaseActor.GetTriangleCount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ADynamicMeshBaseActor::GetTriangleCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DynamicMeshBaseActor", "GetTriangleCount");

	Params::DynamicMeshBaseActor_GetTriangleCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RuntimeGeometryUtils.DynamicMeshBaseActor.ImportMesh
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    Path                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFlipOrientation                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRecomputeNormals                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADynamicMeshBaseActor::ImportMesh(const class FString& Path, bool bFlipOrientation, bool bRecomputeNormals)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DynamicMeshBaseActor", "ImportMesh");

	Params::DynamicMeshBaseActor_ImportMesh Parms{};

	Parms.Path = std::move(Path);
	Parms.bFlipOrientation = bFlipOrientation;
	Parms.bRecomputeNormals = bRecomputeNormals;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RuntimeGeometryUtils.DynamicMeshBaseActor.IntersectRay
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   RayOrigin                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   RayDirection                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         WorldHitPoint                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  HitDistance                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  NearestTriangle                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         TriBaryCoords                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxDistance                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADynamicMeshBaseActor::IntersectRay(const struct FVector& RayOrigin, const struct FVector& RayDirection, struct FVector* WorldHitPoint, float* HitDistance, int32* NearestTriangle, struct FVector* TriBaryCoords, float MaxDistance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DynamicMeshBaseActor", "IntersectRay");

	Params::DynamicMeshBaseActor_IntersectRay Parms{};

	Parms.RayOrigin = std::move(RayOrigin);
	Parms.RayDirection = std::move(RayDirection);
	Parms.MaxDistance = MaxDistance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (WorldHitPoint != nullptr)
		*WorldHitPoint = std::move(Parms.WorldHitPoint);

	if (HitDistance != nullptr)
		*HitDistance = Parms.HitDistance;

	if (NearestTriangle != nullptr)
		*NearestTriangle = Parms.NearestTriangle;

	if (TriBaryCoords != nullptr)
		*TriBaryCoords = std::move(Parms.TriBaryCoords);

	return Parms.ReturnValue;
}


// Function RuntimeGeometryUtils.DynamicMeshBaseActor.IntersectWithMesh
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ADynamicMeshBaseActor*            OtherMesh                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADynamicMeshBaseActor::IntersectWithMesh(class ADynamicMeshBaseActor* OtherMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DynamicMeshBaseActor", "IntersectWithMesh");

	Params::DynamicMeshBaseActor_IntersectWithMesh Parms{};

	Parms.OtherMesh = OtherMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeGeometryUtils.DynamicMeshBaseActor.NearestPoint
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   WorldPoint                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ADynamicMeshBaseActor::NearestPoint(const struct FVector& WorldPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DynamicMeshBaseActor", "NearestPoint");

	Params::DynamicMeshBaseActor_NearestPoint Parms{};

	Parms.WorldPoint = std::move(WorldPoint);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RuntimeGeometryUtils.DynamicMeshBaseActor.SimplifyMeshToTriCount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   TargetTriangleCount                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADynamicMeshBaseActor::SimplifyMeshToTriCount(int32 TargetTriangleCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DynamicMeshBaseActor", "SimplifyMeshToTriCount");

	Params::DynamicMeshBaseActor_SimplifyMeshToTriCount Parms{};

	Parms.TargetTriangleCount = TargetTriangleCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeGeometryUtils.DynamicMeshBaseActor.SolidifyMesh
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   VoxelResolution                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   WindingThreshold                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADynamicMeshBaseActor::SolidifyMesh(int32 VoxelResolution, float WindingThreshold)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DynamicMeshBaseActor", "SolidifyMesh");

	Params::DynamicMeshBaseActor_SolidifyMesh Parms{};

	Parms.VoxelResolution = VoxelResolution;
	Parms.WindingThreshold = WindingThreshold;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeGeometryUtils.DynamicMeshBaseActor.SubtractMesh
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ADynamicMeshBaseActor*            OtherMesh                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADynamicMeshBaseActor::SubtractMesh(class ADynamicMeshBaseActor* OtherMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DynamicMeshBaseActor", "SubtractMesh");

	Params::DynamicMeshBaseActor_SubtractMesh Parms{};

	Parms.OtherMesh = OtherMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeGeometryUtils.DynamicMeshBaseActor.UnionWithMesh
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ADynamicMeshBaseActor*            OtherMesh                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADynamicMeshBaseActor::UnionWithMesh(class ADynamicMeshBaseActor* OtherMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DynamicMeshBaseActor", "UnionWithMesh");

	Params::DynamicMeshBaseActor_UnionWithMesh Parms{};

	Parms.OtherMesh = OtherMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}

}

